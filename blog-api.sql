/*
 Navicat Premium Data Transfer

 Source Server         : local
 Source Server Type    : MySQL
 Source Server Version : 80028
 Source Host           : localhost:3306
 Source Schema         : blog-api

 Target Server Type    : MySQL
 Target Server Version : 80028
 File Encoding         : 65001

 Date: 02/12/2022 22:31:05
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for admin
-- ----------------------------
DROP TABLE IF EXISTS `admin`;
CREATE TABLE `admin`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of admin
-- ----------------------------

-- ----------------------------
-- Table structure for admin_permission
-- ----------------------------
DROP TABLE IF EXISTS `admin_permission`;
CREATE TABLE `admin_permission`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `admin_id` bigint(0) NOT NULL,
  `permission_id` bigint(0) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of admin_permission
-- ----------------------------

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` bigint(0) NOT NULL,
  `comment_counts` int(0) NULL DEFAULT NULL COMMENT '评论数量',
  `create_date` bigint(0) NULL DEFAULT NULL COMMENT '创建时间',
  `summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '简介',
  `title` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `view_counts` int(0) NULL DEFAULT NULL COMMENT '浏览数量',
  `weight` int(0) NOT NULL COMMENT '是否置顶',
  `author_id` bigint(0) NULL DEFAULT NULL COMMENT '作者id',
  `category_id` bigint(0) NULL DEFAULT NULL COMMENT '类别id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (1048014784940736512, 3, 1669907795903, '简要介绍SpringFramework中单例模式和适配器模式的应用', '浅谈Spring中的设计模式（一）', 7, 0, 1048012356757487616, 2);
INSERT INTO `article` VALUES (1048016245409972224, 3, 1669908144106, '简要分析SpringFramework中的模板方法模式', '浅谈Spring中的设计模式（二）', 3, 0, 1048012356757487616, 2);
INSERT INTO `article` VALUES (1048017972309786624, 2, 1669908555831, 'docker基本概念、架构、操作的简介，适合新手。', 'Docker简介', 4, 0, 1048012356757487616, 2);
INSERT INTO `article` VALUES (1048019308057198592, 7, 1669908874298, '简要介绍Java的注解机制和使用。', 'Java注解的介绍与应用', 11, 0, 1048018809429950464, 5);
INSERT INTO `article` VALUES (1048026009816793088, 1, 1669910472122, 'Java反射机制的简要分析', 'Java反射机制', 3, 0, 1048024823428546560, 5);
INSERT INTO `article` VALUES (1048027135333105664, 4, 1669910740466, 'Nacos基础知识的简要介绍', 'Nacos的简单使用', 9, 0, 1048012356757487616, 2);
INSERT INTO `article` VALUES (1048028956206301184, 5, 1669911174596, '写了我个人关于最近大火的梗坤坤的看法，不喜勿喷', '关于某练习生的一点个人看法', 13, 0, 1048021253429919744, 3);
INSERT INTO `article` VALUES (1048308662394683392, 0, 1669977861748, '简要介绍算法的分类标准和核心思想。', '算法分类', 8, 0, 1048012356757487616, 6);

-- ----------------------------
-- Table structure for article_body
-- ----------------------------
DROP TABLE IF EXISTS `article_body`;
CREATE TABLE `article_body`  (
  `article_id` bigint(0) NOT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `content_html` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  PRIMARY KEY (`article_id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_body
-- ----------------------------
INSERT INTO `article_body` VALUES (1048014784940736512, '## Spring中的设计模式\n\n### 单例模式(Singleton Pattern)\n\n<font color=red>Ensure a class has only one instance, and provide a global point of access to it.</font>\n\n确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。\n\n####  类加载\n\n1. 创建类的实例，也就是new一个对象\n\n2. 访问某个类或接口的静态变量，或者对该静态变量赋值\n\n3. 调用类的静态方法\n\n4. 反射（Class.forName(\"com.lyj.load\")）\n\n5. 初始化一个类的子类（会首先初始化子类的父类）\n\n6. JVM启动时标明的启动类，即文件名和类名相同的那个类 只有这6中情况才会导致类的类的初始化。\n\n\n#### 三种反射的区别\n\n- 类名.class：JVM将使用类装载器，将类装入内存(前提是:类还没有装入内存)，不做类的初始化工作，返回Class的对象。\n\n- Class.forName(“类名字符串”)：装入类，并做类的静态初始化，返回Class的对象。\n\n- 实例对象.getClass()：对类进行静态初始化、非静态初始化；返回引用运行时真正所指的对象(子对象的引用会赋给父对象的引用变量中)所属的类的Class的对象。\n\n####  饿汉式单例模式\n\n类加载的时候就立即初始化，并且创建单例对象。它是绝对的线程安全、在线程还没出现以前就实现了，不可能存在访问安全问题。\n\n类加载的时候就初始化单例对象了，用不用都进行，浪费内存\n\n- 写法1\n\n```java\n//写法1\npublic class HungrySingleton {\n    //在类内部就初始化\n    private static final HungrySingleton singleton = new HungrySingleton();\n    //构造函数私有 外部不能访问\n    private HungrySingleton() {\n        System.out.println(\"Hello,I am a HungrySingleton!\");\n    }\n    //全局访问点\n    public static HungrySingleton getSingleton() {\n        return singleton;\n    }\n}\n```\n\n- 写法2\n\n```java\npublic class Singleton {\n     private static Singleton instance = null;\n     //静态代码块\n     static {\n         instance = new Singleton();\n     }\n     private Singleton (){}\n     public static Singleton getInstance() {\n         return instance;\n     }\n}\n```\n\n#### 懒汉式单例模式\n\n- 简单懒汉写法\n\n多线程不安全\n\n```java\n//简单懒汉写法\npublic class LazySingleton {\n    //静态类对象 一开始并不初始化\n    private static LazySingleton singleton = null;\n    //构造函数私有 外界不能访问\n    private LazySingleton() {\n    }\n    public static LazySingleton getInstance() {\n        if (singleton == null) {\n            singleton = new LazySingleton();\n        }\n        return singleton;\n	}\n```\n\n- Double-Check写法\n\n阻塞大量线程，性能下降\n\n```java\n//Double-Check写法\n    public static LazySingleton getInstance() {\n        if (singleton == null) {\n            synchronized (LazySingleton.class) {\n                if (singleton == null) {\n                    singleton = new LazySingleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n\n- 内部类\n\n可以被反射和序列化破坏\n\n```java\n//内部类写法\npublic class LazyInnerClassSingleton {\n    //私有的构造函数\n    private LazyInnerClassSingleton() {\n    }\n    public static final LazyInnerClassSingleton getInstance() {\n        return LazyHolder.singleton;\n    }\n    //外部类加载时,静态内部类并不加载\n    private static class LazyHolder {\n        private static final LazyInnerClassSingleton singleton = new LazyInnerClassSingleton();\n    }\n}  \n```\n\n#### 枚举式单例模式\n\nhttps://blog.csdn.net/qq_36448587/article/details/107253971\n![effectivejava.jpg](http://rm51mx6mn.hn-bkt.clouddn.com/b3e23065-8a85-404e-b0d5-b34d002b46f2.jpg)\n```java\npublic enum EnumSingleton {\n    //枚举单例 \n    SINGLETON;\n}\n```\n\n#### 容器式单例模式\n\n非线程安全\n\n```java\npublic class ContainerSingleton {\n    private ContainerSingleton() {\n    }\n		//ConcurrentHashMap是HashMap的升级版 HashMap是线程不安全的 而ConcurrentHashMap是线程安全\n    private static Map<String, Object> ioc = new ConcurrentHashMap<>();\n\n    public static Object getBean(String className) {\n        synchronized (ioc) {\n            if (!ioc.containsKey(className)) {\n                Object o = null;\n                try {\n                    o = Class.forName(className).newInstance();\n                    ioc.put(className, o);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                return o;\n            } else {\n                return ioc.get(className);\n            }\n        }\n    }\n}\n```\n\n#### Spring中的单例\n\n```java\nprotected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {\n  			//对Bean的名字进行处理 防止有非法字符等\n        String beanName = this.transformedBeanName(name);\n  			//调用getSingleton方法从获取bean单例\n        Object sharedInstance = this.getSingleton(beanName);\n 	 			Object bean;\n  			//如果获取到了单例的bean\n        if (sharedInstance != null && args == null) {          \n       	......\n        } else {\n            if (this.isPrototypeCurrentlyInCreation(beanName)) {\n                throw new BeanCurrentlyInCreationException(beanName);\n            }\n\n            BeanFactory parentBeanFactory = this.getParentBeanFactory();\n            if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)){\n              ......\n        } else {\n            return bean;\n        }\n    }\n```\n\n```java\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap(256);\nprivate final Map<String, ObjectFactory<?>> singletonFactories = new HashMap(16);\nprivate final Map<String, Object> earlySingletonObjects = new ConcurrentHashMap(16);\n\n\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n //首先从singletonObjects中获取单例对象（一级缓存）       \n  Object singletonObject = this.singletonObjects.get(beanName);\n  //如果没有获取到 并且此单例没有在创建 \n  //isSingletonCurrentlyInCreation的作用判断这个beanName是不是正在创建，也就是判断是不是循环依赖了。\n        if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {\n          //从earlySingletonObjects中获取（二级缓存）\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null && allowEarlyReference) {\n                synchronized(this.singletonObjects) {\n                    singletonObject = this.singletonObjects.get(beanName);\n                    if (singletonObject == null) {\n                        singletonObject = this.earlySingletonObjects.get(beanName);\n                        if (singletonObject == null) {\n                          //从singletonFactories中获取\n                            ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);\n                            if (singletonFactory != null) {\n                                singletonObject = singletonFactory.getObject();\n                                this.earlySingletonObjects.put(beanName, singletonObject);\n                                this.singletonFactories.remove(beanName);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return singletonObject;\n    }\n```\n\n单例的获取顺利是**singletonObjects ——>earlySingletonObjects ——>singletonFactories** 这样的三级层次。\n\n在singletonObjects 中获取bean的时候，没有使用synchronized关键字，而在singletonFactories 和earlySingletonObjects 中的操作都是在synchronized代码块中完成的，正好和他们各自的数据类型对应，singletonObjects 使用的使用ConcurrentHashMap线程安全，而singletonFactories 和earlySingletonObjects 使用的是HashMap，线程不安全。\n\n从字面意思来说：singletonObjects指单例对象的cache，singletonFactories指单例对象工厂的cache，earlySingletonObjects指提前曝光的单例对象的cache。以上三个cache构成了三级缓存，Spring就用这三级缓存巧妙的解决了循环依赖问题。\n\n**Spring创建bean是线程安全的，不代表bean的使用是线程安全的。Spring中bean没有使用任何的线程安全措施，对单例且有状态的bean是不安全的，prototype多例的bean和无状态的bean是线程安全的。**\n\n### 适配器模式(Adapter Pattern/Wrapper)\n\n<font color=red>Convert the inface of a class into another interface clients expect.Adapter lets classes work together that couldn\'t otherwise because of incompatible interface.</font>\n\n将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作.\n\n*<u>”没有什么问题是加一层不能解决的“</u>*\n\n###### 优点\n\n- 更好的**复用性**：系统需要使用现有的类，但是此类的接口不符合系统需要。那么通过适配器模式就可以让这些功能得到更好的复用（原有的功能不需要再实现一遍）\n- 更好的**扩展性**：在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能（不用修改原有代码）\n\n###### 缺点\n\n过多的使用适配器，会使系统非常凌乱，不易整体进把握。\n\n#### 类适配器\n![类适配器.jpg](http://rm51mx6mn.hn-bkt.clouddn.com/b4f7c42a-e490-479a-ac98-96bc641dcda3.jpg)\n```java\npublic interface Target {\n    void request();\n}\n\npublic class Adaptee {\n    public void specificRequest() {\n        System.out.println(\"specificRequest...\");\n    }\n}\n\npublic class Adapter extends Adaptee implements Target{\n    @Override\n    public void request() {\n        specificRequest();\n    }\n}\n```\n#### 对象适配器\n![对象适配器.jpg](http://rm51mx6mn.hn-bkt.clouddn.com/27051db9-baaa-4aa0-8d83-a56c95821c57.jpg)\n```java\npublic interface Target {\n    void request();\n}\n\npublic class Adaptee {\n    public void specificRequest() {\n        System.out.println(\"specificRequest...\");\n    }\n}\n\npublic class Adapter implements Target {\n    private Adaptee adaptee;\n\n    public Adapter(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n    @Override\n    public void request() {\n        adaptee.specificRequest();\n    }\n}\n```\n\n#### 缺省适配器\n\n当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中的每个方法提供一个默认实现(空方法)，该抽象类可以有选择性的覆盖父类的某些方法来实现需求。\n![缺省适配器.jpg](http://rm51mx6mn.hn-bkt.clouddn.com/279a037a-fc09-4846-aae7-857122f3e6a7.jpg)\n#### 双向适配器\n\n在对象适配器中如果同时包含目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法\n\n#### Spring中的适配器模式\n\nSpringAOP和SpringMVC中都有用到适配器模式。\n\nSpringAOP 中的 AdvisorAdapter 类，它有三个实现类 MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter 和ThrowsAdviceAdapter。\n![适配器图.png](http://rm51mx6mn.hn-bkt.clouddn.com/2b5fae60-a304-461e-b254-010b27bddb3b.png)\n```java\n//springframework-->aop-->framework-->adapter包\n\n//Target\npublic interface AdvisorAdapter {\n    boolean supportsAdvice(Advice var1);\n\n    MethodInterceptor getInterceptor(Advisor var1);\n}\n//Adapter\n//适配MethodBeforeAdviceInterceptor 接口getInterceptor(Advisor advisor)\n//进行一层包装 对外提供想要的方法\nclass MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {\n    MethodBeforeAdviceAdapter() {\n    }\n		@Override\n    public boolean supportsAdvice(Advice advice) {\n        return advice instanceof MethodBeforeAdvice;\n    }\n		@Override\n    public MethodInterceptor getInterceptor(Advisor advisor) {\n        MethodBeforeAdvice advice = (MethodBeforeAdvice)advisor.getAdvice();\n        return new MethodBeforeAdviceInterceptor(advice);\n    }\n}\n//Adaptee\npublic interface MethodBeforeAdvice extends BeforeAdvice {\n    void before(Method var1, Object[] var2, @Nullable Object var3) throws Throwable;\n}\n//client \n//调用AdvisorAdapter对外暴露的接口\npublic class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry, Serializable {\n    private final List<AdvisorAdapter> adapters = new ArrayList(3);\n\n    public DefaultAdvisorAdapterRegistry() {\n        this.registerAdvisorAdapter(new MethodBeforeAdviceAdapter());\n        this.registerAdvisorAdapter(new AfterReturningAdviceAdapter());\n        this.registerAdvisorAdapter(new ThrowsAdviceAdapter());\n    }	\n    public Advisor wrap(Object adviceObject) throws UnknownAdviceTypeException {\n        ......\n    }\n		// 获取适配器对应的所有的拦截器\n    public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {\n        List<MethodInterceptor> interceptors = new ArrayList(3);\n        Advice advice = advisor.getAdvice();\n        if (advice instanceof MethodInterceptor) {\n            interceptors.add((MethodInterceptor)advice);\n        }\n\n        Iterator var4 = this.adapters.iterator();\n\n        while(var4.hasNext()) {\n            AdvisorAdapter adapter = (AdvisorAdapter)var4.next();\n            if (adapter.supportsAdvice(advice)) {\n                interceptors.add(adapter.getInterceptor(advisor));\n            }\n        }\n\n        if (interceptors.isEmpty()) {\n            throw new UnknownAdviceTypeException(advisor.getAdvice());\n        } else {\n            return (MethodInterceptor[])interceptors.toArray(new MethodInterceptor[0]);\n        }\n    }\n\n    public void registerAdvisorAdapter(AdvisorAdapter adapter) {\n        this.adapters.add(adapter);\n    }\n}\n\n```\n', '<h2><a id=\"Spring_0\"></a>Spring中的设计模式</h2>\n<h3><a id=\"Singleton_Pattern_2\"></a>单例模式(Singleton Pattern)</h3>\n<p><font color=red>Ensure a class has only one instance, and provide a global point of access to it.</font></p>\n<p>确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。</p>\n<h4><a id=\"_8\"></a>类加载</h4>\n<ol>\n<li>\n<p>创建类的实例，也就是new一个对象</p>\n</li>\n<li>\n<p>访问某个类或接口的静态变量，或者对该静态变量赋值</p>\n</li>\n<li>\n<p>调用类的静态方法</p>\n</li>\n<li>\n<p>反射（Class.forName(“com.lyj.load”)）</p>\n</li>\n<li>\n<p>初始化一个类的子类（会首先初始化子类的父类）</p>\n</li>\n<li>\n<p>JVM启动时标明的启动类，即文件名和类名相同的那个类 只有这6中情况才会导致类的类的初始化。</p>\n</li>\n</ol>\n<h4><a id=\"_23\"></a>三种反射的区别</h4>\n<ul>\n<li>\n<p>类名.class：JVM将使用类装载器，将类装入内存(前提是:类还没有装入内存)，不做类的初始化工作，返回Class的对象。</p>\n</li>\n<li>\n<p>Class.forName(“类名字符串”)：装入类，并做类的静态初始化，返回Class的对象。</p>\n</li>\n<li>\n<p>实例对象.getClass()：对类进行静态初始化、非静态初始化；返回引用运行时真正所指的对象(子对象的引用会赋给父对象的引用变量中)所属的类的Class的对象。</p>\n</li>\n</ul>\n<h4><a id=\"_31\"></a>饿汉式单例模式</h4>\n<p>类加载的时候就立即初始化，并且创建单例对象。它是绝对的线程安全、在线程还没出现以前就实现了，不可能存在访问安全问题。</p>\n<p>类加载的时候就初始化单例对象了，用不用都进行，浪费内存</p>\n<ul>\n<li>写法1</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//写法1</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HungrySingleton</span> </span>{\n    <span class=\"hljs-comment\">//在类内部就初始化</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> HungrySingleton singleton = <span class=\"hljs-keyword\">new</span> HungrySingleton();\n    <span class=\"hljs-comment\">//构造函数私有 外部不能访问</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">HungrySingleton</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"Hello,I am a HungrySingleton!\"</span>);\n    }\n    <span class=\"hljs-comment\">//全局访问点</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> HungrySingleton <span class=\"hljs-title\">getSingleton</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> singleton;\n    }\n}\n</code></div></pre>\n<ul>\n<li>写法2</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> </span>{\n     <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Singleton instance = <span class=\"hljs-keyword\">null</span>;\n     <span class=\"hljs-comment\">//静态代码块</span>\n     <span class=\"hljs-keyword\">static</span> {\n         instance = <span class=\"hljs-keyword\">new</span> Singleton();\n     }\n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span> <span class=\"hljs-params\">()</span></span>{}\n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n         <span class=\"hljs-keyword\">return</span> instance;\n     }\n}\n</code></div></pre>\n<h4><a id=\"_71\"></a>懒汉式单例模式</h4>\n<ul>\n<li>简单懒汉写法</li>\n</ul>\n<p>多线程不安全</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//简单懒汉写法</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LazySingleton</span> </span>{\n    <span class=\"hljs-comment\">//静态类对象 一开始并不初始化</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> LazySingleton singleton = <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-comment\">//构造函数私有 外界不能访问</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">LazySingleton</span><span class=\"hljs-params\">()</span> </span>{\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> LazySingleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (singleton == <span class=\"hljs-keyword\">null</span>) {\n            singleton = <span class=\"hljs-keyword\">new</span> LazySingleton();\n        }\n        <span class=\"hljs-keyword\">return</span> singleton;\n	}\n</code></div></pre>\n<ul>\n<li>Double-Check写法</li>\n</ul>\n<p>阻塞大量线程，性能下降</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//Double-Check写法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> LazySingleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (singleton == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">synchronized</span> (LazySingleton.class) {\n                <span class=\"hljs-keyword\">if</span> (singleton == <span class=\"hljs-keyword\">null</span>) {\n                    singleton = <span class=\"hljs-keyword\">new</span> LazySingleton();\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> singleton;\n    }\n}\n</code></div></pre>\n<ul>\n<li>内部类</li>\n</ul>\n<p>可以被反射和序列化破坏</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//内部类写法</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LazyInnerClassSingleton</span> </span>{\n    <span class=\"hljs-comment\">//私有的构造函数</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">LazyInnerClassSingleton</span><span class=\"hljs-params\">()</span> </span>{\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> LazyInnerClassSingleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> LazyHolder.singleton;\n    }\n    <span class=\"hljs-comment\">//外部类加载时,静态内部类并不加载</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LazyHolder</span> </span>{\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> LazyInnerClassSingleton singleton = <span class=\"hljs-keyword\">new</span> LazyInnerClassSingleton();\n    }\n}  \n</code></div></pre>\n<h4><a id=\"_132\"></a>枚举式单例模式</h4>\n<p>https://blog.csdn.net/qq_36448587/article/details/107253971<br />\n<img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/b3e23065-8a85-404e-b0d5-b34d002b46f2.jpg\" alt=\"effectivejava.jpg\" /></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> EnumSingleton {\n    <span class=\"hljs-comment\">//枚举单例 </span>\n    SINGLETON;\n}\n</code></div></pre>\n<h4><a id=\"_143\"></a>容器式单例模式</h4>\n<p>非线程安全</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ContainerSingleton</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">ContainerSingleton</span><span class=\"hljs-params\">()</span> </span>{\n    }\n		<span class=\"hljs-comment\">//ConcurrentHashMap是HashMap的升级版 HashMap是线程不安全的 而ConcurrentHashMap是线程安全</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Map&lt;String, Object&gt; ioc = <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;&gt;();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Object <span class=\"hljs-title\">getBean</span><span class=\"hljs-params\">(String className)</span> </span>{\n        <span class=\"hljs-keyword\">synchronized</span> (ioc) {\n            <span class=\"hljs-keyword\">if</span> (!ioc.containsKey(className)) {\n                Object o = <span class=\"hljs-keyword\">null</span>;\n                <span class=\"hljs-keyword\">try</span> {\n                    o = Class.forName(className).newInstance();\n                    ioc.put(className, o);\n                } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n                    e.printStackTrace();\n                }\n                <span class=\"hljs-keyword\">return</span> o;\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">return</span> ioc.get(className);\n            }\n        }\n    }\n}\n</code></div></pre>\n<h4><a id=\"Spring_173\"></a>Spring中的单例</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">protected</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">doGetBean</span><span class=\"hljs-params\">(String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, <span class=\"hljs-keyword\">boolean</span> typeCheckOnly)</span> <span class=\"hljs-keyword\">throws</span> BeansException </span>{\n  			<span class=\"hljs-comment\">//对Bean的名字进行处理 防止有非法字符等</span>\n        String beanName = <span class=\"hljs-keyword\">this</span>.transformedBeanName(name);\n  			<span class=\"hljs-comment\">//调用getSingleton方法从获取bean单例</span>\n        Object sharedInstance = <span class=\"hljs-keyword\">this</span>.getSingleton(beanName);\n 	 			Object bean;\n  			<span class=\"hljs-comment\">//如果获取到了单例的bean</span>\n        <span class=\"hljs-keyword\">if</span> (sharedInstance != <span class=\"hljs-keyword\">null</span> &amp;&amp; args == <span class=\"hljs-keyword\">null</span>) {          \n       	......\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.isPrototypeCurrentlyInCreation(beanName)) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> BeanCurrentlyInCreationException(beanName);\n            }\n\n            BeanFactory parentBeanFactory = <span class=\"hljs-keyword\">this</span>.getParentBeanFactory();\n            <span class=\"hljs-keyword\">if</span> (parentBeanFactory != <span class=\"hljs-keyword\">null</span> &amp;&amp; !<span class=\"hljs-keyword\">this</span>.containsBeanDefinition(beanName)){\n              ......\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> bean;\n        }\n    }\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Map&lt;String, Object&gt; singletonObjects = <span class=\"hljs-keyword\">new</span> ConcurrentHashMap(<span class=\"hljs-number\">256</span>);\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class=\"hljs-keyword\">new</span> HashMap(<span class=\"hljs-number\">16</span>);\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class=\"hljs-keyword\">new</span> ConcurrentHashMap(<span class=\"hljs-number\">16</span>);\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title\">getSingleton</span><span class=\"hljs-params\">(String beanName, <span class=\"hljs-keyword\">boolean</span> allowEarlyReference)</span> </span>{\n <span class=\"hljs-comment\">//首先从singletonObjects中获取单例对象（一级缓存）       </span>\n  Object singletonObject = <span class=\"hljs-keyword\">this</span>.singletonObjects.get(beanName);\n  <span class=\"hljs-comment\">//如果没有获取到 并且此单例没有在创建 </span>\n  <span class=\"hljs-comment\">//isSingletonCurrentlyInCreation的作用判断这个beanName是不是正在创建，也就是判断是不是循环依赖了。</span>\n        <span class=\"hljs-keyword\">if</span> (singletonObject == <span class=\"hljs-keyword\">null</span> &amp;&amp; <span class=\"hljs-keyword\">this</span>.isSingletonCurrentlyInCreation(beanName)) {\n          <span class=\"hljs-comment\">//从earlySingletonObjects中获取（二级缓存）</span>\n            singletonObject = <span class=\"hljs-keyword\">this</span>.earlySingletonObjects.get(beanName);\n            <span class=\"hljs-keyword\">if</span> (singletonObject == <span class=\"hljs-keyword\">null</span> &amp;&amp; allowEarlyReference) {\n                <span class=\"hljs-keyword\">synchronized</span>(<span class=\"hljs-keyword\">this</span>.singletonObjects) {\n                    singletonObject = <span class=\"hljs-keyword\">this</span>.singletonObjects.get(beanName);\n                    <span class=\"hljs-keyword\">if</span> (singletonObject == <span class=\"hljs-keyword\">null</span>) {\n                        singletonObject = <span class=\"hljs-keyword\">this</span>.earlySingletonObjects.get(beanName);\n                        <span class=\"hljs-keyword\">if</span> (singletonObject == <span class=\"hljs-keyword\">null</span>) {\n                          <span class=\"hljs-comment\">//从singletonFactories中获取</span>\n                            ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)<span class=\"hljs-keyword\">this</span>.singletonFactories.get(beanName);\n                            <span class=\"hljs-keyword\">if</span> (singletonFactory != <span class=\"hljs-keyword\">null</span>) {\n                                singletonObject = singletonFactory.getObject();\n                                <span class=\"hljs-keyword\">this</span>.earlySingletonObjects.put(beanName, singletonObject);\n                                <span class=\"hljs-keyword\">this</span>.singletonFactories.remove(beanName);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        <span class=\"hljs-keyword\">return</span> singletonObject;\n    }\n</code></div></pre>\n<p>单例的获取顺利是<strong>singletonObjects ——&gt;earlySingletonObjects ——&gt;singletonFactories</strong> 这样的三级层次。</p>\n<p>在singletonObjects 中获取bean的时候，没有使用synchronized关键字，而在singletonFactories 和earlySingletonObjects 中的操作都是在synchronized代码块中完成的，正好和他们各自的数据类型对应，singletonObjects 使用的使用ConcurrentHashMap线程安全，而singletonFactories 和earlySingletonObjects 使用的是HashMap，线程不安全。</p>\n<p>从字面意思来说：singletonObjects指单例对象的cache，singletonFactories指单例对象工厂的cache，earlySingletonObjects指提前曝光的单例对象的cache。以上三个cache构成了三级缓存，Spring就用这三级缓存巧妙的解决了循环依赖问题。</p>\n<p><strong>Spring创建bean是线程安全的，不代表bean的使用是线程安全的。Spring中bean没有使用任何的线程安全措施，对单例且有状态的bean是不安全的，prototype多例的bean和无状态的bean是线程安全的。</strong></p>\n<h3><a id=\"Adapter_PatternWrapper_244\"></a>适配器模式(Adapter Pattern/Wrapper)</h3>\n<p><font color=red>Convert the inface of a class into another interface clients expect.Adapter lets classes work together that couldn’t otherwise because of incompatible interface.</font></p>\n<p>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作.</p>\n<p><em><u>”没有什么问题是加一层不能解决的“</u></em></p>\n<h6><a id=\"_252\"></a>优点</h6>\n<ul>\n<li>更好的<strong>复用性</strong>：系统需要使用现有的类，但是此类的接口不符合系统需要。那么通过适配器模式就可以让这些功能得到更好的复用（原有的功能不需要再实现一遍）</li>\n<li>更好的<strong>扩展性</strong>：在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能（不用修改原有代码）</li>\n</ul>\n<h6><a id=\"_257\"></a>缺点</h6>\n<p>过多的使用适配器，会使系统非常凌乱，不易整体进把握。</p>\n<h4><a id=\"_261\"></a>类适配器</h4>\n<p><img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/b4f7c42a-e490-479a-ac98-96bc641dcda3.jpg\" alt=\"类适配器.jpg\" /></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Target</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">request</span><span class=\"hljs-params\">()</span></span>;\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Adaptee</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">specificRequest</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"specificRequest...\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Adapter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Adaptee</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Target</span></span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">request</span><span class=\"hljs-params\">()</span> </span>{\n        specificRequest();\n    }\n}\n</code></div></pre>\n<h4><a id=\"_281\"></a>对象适配器</h4>\n<p><img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/27051db9-baaa-4aa0-8d83-a56c95821c57.jpg\" alt=\"对象适配器.jpg\" /></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Target</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">request</span><span class=\"hljs-params\">()</span></span>;\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Adaptee</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">specificRequest</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"specificRequest...\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Adapter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Target</span> </span>{\n    <span class=\"hljs-keyword\">private</span> Adaptee adaptee;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Adapter</span><span class=\"hljs-params\">(Adaptee adaptee)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.adaptee = adaptee;\n    }\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">request</span><span class=\"hljs-params\">()</span> </span>{\n        adaptee.specificRequest();\n    }\n}\n</code></div></pre>\n<h4><a id=\"_307\"></a>缺省适配器</h4>\n<p>当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中的每个方法提供一个默认实现(空方法)，该抽象类可以有选择性的覆盖父类的某些方法来实现需求。<br />\n<img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/279a037a-fc09-4846-aae7-857122f3e6a7.jpg\" alt=\"缺省适配器.jpg\" /></p>\n<h4><a id=\"_311\"></a>双向适配器</h4>\n<p>在对象适配器中如果同时包含目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法</p>\n<h4><a id=\"Spring_315\"></a>Spring中的适配器模式</h4>\n<p>SpringAOP和SpringMVC中都有用到适配器模式。</p>\n<p>SpringAOP 中的 AdvisorAdapter 类，它有三个实现类 MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter 和ThrowsAdviceAdapter。<br />\n<img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/2b5fae60-a304-461e-b254-010b27bddb3b.png\" alt=\"适配器图.png\" /></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//springframework--&gt;aop--&gt;framework--&gt;adapter包</span>\n\n<span class=\"hljs-comment\">//Target</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">AdvisorAdapter</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">supportsAdvice</span><span class=\"hljs-params\">(Advice var1)</span></span>;\n\n    <span class=\"hljs-function\">MethodInterceptor <span class=\"hljs-title\">getInterceptor</span><span class=\"hljs-params\">(Advisor var1)</span></span>;\n}\n<span class=\"hljs-comment\">//Adapter</span>\n<span class=\"hljs-comment\">//适配MethodBeforeAdviceInterceptor 接口getInterceptor(Advisor advisor)</span>\n<span class=\"hljs-comment\">//进行一层包装 对外提供想要的方法</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MethodBeforeAdviceAdapter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">AdvisorAdapter</span>, <span class=\"hljs-title\">Serializable</span> </span>{\n    MethodBeforeAdviceAdapter() {\n    }\n		<span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">supportsAdvice</span><span class=\"hljs-params\">(Advice advice)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> advice <span class=\"hljs-keyword\">instanceof</span> MethodBeforeAdvice;\n    }\n		<span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> MethodInterceptor <span class=\"hljs-title\">getInterceptor</span><span class=\"hljs-params\">(Advisor advisor)</span> </span>{\n        MethodBeforeAdvice advice = (MethodBeforeAdvice)advisor.getAdvice();\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MethodBeforeAdviceInterceptor(advice);\n    }\n}\n<span class=\"hljs-comment\">//Adaptee</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">MethodBeforeAdvice</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BeforeAdvice</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">before</span><span class=\"hljs-params\">(Method var1, Object[] var2, @Nullable Object var3)</span> <span class=\"hljs-keyword\">throws</span> Throwable</span>;\n}\n<span class=\"hljs-comment\">//client </span>\n<span class=\"hljs-comment\">//调用AdvisorAdapter对外暴露的接口</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DefaultAdvisorAdapterRegistry</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">AdvisorAdapterRegistry</span>, <span class=\"hljs-title\">Serializable</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> List&lt;AdvisorAdapter&gt; adapters = <span class=\"hljs-keyword\">new</span> ArrayList(<span class=\"hljs-number\">3</span>);\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">DefaultAdvisorAdapterRegistry</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.registerAdvisorAdapter(<span class=\"hljs-keyword\">new</span> MethodBeforeAdviceAdapter());\n        <span class=\"hljs-keyword\">this</span>.registerAdvisorAdapter(<span class=\"hljs-keyword\">new</span> AfterReturningAdviceAdapter());\n        <span class=\"hljs-keyword\">this</span>.registerAdvisorAdapter(<span class=\"hljs-keyword\">new</span> ThrowsAdviceAdapter());\n    }	\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Advisor <span class=\"hljs-title\">wrap</span><span class=\"hljs-params\">(Object adviceObject)</span> <span class=\"hljs-keyword\">throws</span> UnknownAdviceTypeException </span>{\n        ......\n    }\n		<span class=\"hljs-comment\">// 获取适配器对应的所有的拦截器</span>\n    <span class=\"hljs-keyword\">public</span> MethodInterceptor[] getInterceptors(Advisor advisor) <span class=\"hljs-keyword\">throws</span> UnknownAdviceTypeException {\n        List&lt;MethodInterceptor&gt; interceptors = <span class=\"hljs-keyword\">new</span> ArrayList(<span class=\"hljs-number\">3</span>);\n        Advice advice = advisor.getAdvice();\n        <span class=\"hljs-keyword\">if</span> (advice <span class=\"hljs-keyword\">instanceof</span> MethodInterceptor) {\n            interceptors.add((MethodInterceptor)advice);\n        }\n\n        Iterator var4 = <span class=\"hljs-keyword\">this</span>.adapters.iterator();\n\n        <span class=\"hljs-keyword\">while</span>(var4.hasNext()) {\n            AdvisorAdapter adapter = (AdvisorAdapter)var4.next();\n            <span class=\"hljs-keyword\">if</span> (adapter.supportsAdvice(advice)) {\n                interceptors.add(adapter.getInterceptor(advisor));\n            }\n        }\n\n        <span class=\"hljs-keyword\">if</span> (interceptors.isEmpty()) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnknownAdviceTypeException(advisor.getAdvice());\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> (MethodInterceptor[])interceptors.toArray(<span class=\"hljs-keyword\">new</span> MethodInterceptor[<span class=\"hljs-number\">0</span>]);\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerAdvisorAdapter</span><span class=\"hljs-params\">(AdvisorAdapter adapter)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.adapters.add(adapter);\n    }\n}\n\n</code></div></pre>\n');
INSERT INTO `article_body` VALUES (1048016245409972224, '### 模板方法模式(Template Method Pattern)\n\n<font color=red>Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclass redefine certain steps of an algorithm without changing the algorithm\'s  structure.</font>\n\n 定义一个操作中的算法框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤。\n\n###### 优点\n\n- 封装了不变部分，扩展可变部分。\n\n- 在父类中提取了公共的部分代码，便于代码复用。\n- 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。\n\n###### 缺点\n\n- 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。\n- 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。\n- 由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。\n![模板方法模式.jpg](http://rm51mx6mn.hn-bkt.clouddn.com/e9149e8c-1fb4-4017-9842-e4a07b43d7cb.jpg)\n\n```java\npublic abstract class AbstractClass {\n    // 共同的且繁琐的操作\n    private void baseOperation() {\n        // do something\n    }\n\n    // 由子类定制的操作\n    protected abstract void customOperation();\n\n    // 模板方法定义的框架\n    public final void templateMethod() {\n        /**\n         * 调用基本方法，完成固定逻辑\n         */\n        baseOperation();\n        customOperation();\n    }\n}\n\npublic class CustomClass1 extends AbstractClass{\n    @Override\n    protected void customOperation() {\n        // 具体模板1 业务逻辑\n        System.out.println(\"具体模板1：customOperation()\");\n    }\n}\n\npublic class CustomClass2 extends AbstractClass{\n    @Override\n    protected void customOperation() {\n        // 具体模板2 业务逻辑\n        System.out.println(\"具体模板2：customOperation()\");\n    }\n}\n```\n\n#### 回调方式\n\n```java\npublic interface CallBack {\n    void customOperation();\n}\npublic class SubCallBack implements CallBack{\n    @Override\n    public void customOperation() {\n        System.out.println(\"callback operation1...\");\n    }\n}\npublic final class Template {\n    private void baseOperation(){\n        System.out.println(\"模板类公共操作\");\n    }\n\n    public void templateMethod(CallBack callback){\n        baseOperation();\n        callback.customOperation();\n    }\n}\n```\n\n#### 钩子函数\n\n设计钩子方法的主要目的是干预模板方法的执行流程，使得控制行为流程更加灵活，更符合实际业务的需求。钩子方法的返回值一般为适合条件分支语句的返回值（如boolean、int等）。子类可以自行选择重写。\n\n```java\npublic abstract class AbstractBasePay implements BasePay {\n\n    @Override\n    public final void mobilePay() {\n        // 钩子函数\n        if (isCheckAuth()) {\n            checkAuth();\n        }\n        checkParam();\n        checkRisk();\n        channlePay();\n    }\n\n    private void checkParam() {\n        System.out.println(\"检查参数\");\n    }\n    \n    private void checkAuth() {\n        System.out.println(\"支付权限校验\");\n    }\n    \n    private void checkRisk() {\n        System.out.println(\"风控校验\");\n    }\n    \n    //渠道支付\n    abstract void channlePay();\n    \n    //钩子函数，子类可以覆写，来选择手开启支付权限校验  默认不开启\n    boolean isCheckAuth() {\n        return true;\n    }\n}\n```\n\n```java\n\npublic class EBankChannelPay extends AbstractBasePay{\n\n    @Override\n    void channlePay() {\n        System.out.println(\"网银支付\");\n    }\n    \n    boolean isCheckAuth() {\n        return false;\n    }\n}\n```\n\n\n\n#### Spring中的模板方法模式\n\n在spring源码中使用到模板模式的有以下几类（**在Spring中大多数模板方式都是行为接口的定义：Callback**）：\n\n- **RestTemplate Http Restful接口请求模板**\n- **AsyncRestTemplate 异步Http Restful接口请求模板**\n- **JdbcTemplate JDBC关系型数据库操作模板**\n- **HibernateTemplate Hibernate关系型数据库操作模板**\n- **JmsTemplate 消息队列模板**\n- **TransactionTemplate 编程式事务模板**\n\n带有Template的基本都是模板方法模式。\n\n##### JdbcTemplate\n\nJdbcTemplate是JDBC核心软件包中的中心类。它简化了JDBC的使用，并有助于避免常见错误。它执行核心JDBC工作流程，留下应用程序代码以提供SQL并提取结果\n\nspring通过JdbcTemplate提供原生的JDBC SQL语句执行操作。JdbcTemplate和JdbcOperations均位于org.springframework.jdbc.core下.\n\nJdbcOperations提供最基本的SQL方法执行接口，JdbcTemplate负责模板方法调用。\n\n```java\n@FunctionalInterface\npublic interface ConnectionCallback<T> {\n    @Nullable\n    T doInConnection(Connection var1) throws SQLException, DataAccessException;\n}\n\n@Nullable\n    public <T> T execute(ConnectionCallback<T> action) throws DataAccessException {\n        Assert.notNull(action, \"Callback object must not be null\");\n        Connection con = DataSourceUtils.getConnection(this.obtainDataSource());\n\n        Object var10;\n        try {\n            Connection conToUse = this.createConnectionProxy(con);\n            var10 = action.doInConnection(conToUse);\n        } catch (SQLException var8) {\n            String sql = getSql(action);\n            DataSourceUtils.releaseConnection(con, this.getDataSource());\n            con = null;\n            throw this.translateException(\"ConnectionCallback\", sql, var8);\n        } finally {\n            DataSourceUtils.releaseConnection(con, this.getDataSource());\n        }\n\n        return var10;\n    }\n```\n\n```java\n@FunctionalInterface\npublic interface StatementCallback<T> {\n    @Nullable\n    T doInStatement(Statement var1) throws SQLException, DataAccessException;\n}\n\n@Nullable\n    public <T> T execute(StatementCallback<T> action) throws DataAccessException {\n        Assert.notNull(action, \"Callback object must not be null\");\n      //1.获得连接  \n      Connection con = DataSourceUtils.getConnection(this.obtainDataSource());\n        Statement stmt = null;\n\n        Object var11;\n        try {\n           //2.创建语句\n            stmt = con.createStatement();\n            this.applyStatementSettings(stmt);\n          //3.执行语句\n            T result = action.doInStatement(stmt);\n            this.handleWarnings(stmt);\n            var11 = result;\n        } catch (SQLException var9) {\n            String sql = getSql(action);\n            JdbcUtils.closeStatement(stmt);\n            stmt = null;\n            DataSourceUtils.releaseConnection(con, this.getDataSource());\n            con = null;\n            throw this.translateException(\"StatementCallback\", sql, var9);\n        } finally {\n          //4.关闭语句\n            JdbcUtils.closeStatement(stmt);\n          //5.释放连接\n            DataSourceUtils.releaseConnection(con, this.getDataSource());\n        }\n        return var11;\n    }\n```\n\n子类在实现该接口时，需要实现回调接口中的`doInStatement`方法，即执行SQL的相关逻辑，这样模板方法就会因doInstatement的不同逻辑而呈现不同的功能，如查询、更新等。\n', '<h3><a id=\"Template_Method_Pattern_0\"></a>模板方法模式(Template Method Pattern)</h3>\n<p><font color=red>Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclass redefine certain steps of an algorithm without changing the algorithm’s  structure.</font></p>\n<p>定义一个操作中的算法框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤。</p>\n<h6><a id=\"_6\"></a>优点</h6>\n<ul>\n<li>\n<p>封装了不变部分，扩展可变部分。</p>\n</li>\n<li>\n<p>在父类中提取了公共的部分代码，便于代码复用。</p>\n</li>\n<li>\n<p>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</p>\n</li>\n</ul>\n<h6><a id=\"_13\"></a>缺点</h6>\n<ul>\n<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。</li>\n<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>\n<li>由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。<br />\n<img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/e9149e8c-1fb4-4017-9842-e4a07b43d7cb.jpg\" alt=\"模板方法模式.jpg\" /></li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AbstractClass</span> </span>{\n    <span class=\"hljs-comment\">// 共同的且繁琐的操作</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">baseOperation</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// do something</span>\n    }\n\n    <span class=\"hljs-comment\">// 由子类定制的操作</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">customOperation</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-comment\">// 模板方法定义的框架</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">templateMethod</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">/**\n         * 调用基本方法，完成固定逻辑\n         */</span>\n        baseOperation();\n        customOperation();\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomClass1</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractClass</span></span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">customOperation</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// 具体模板1 业务逻辑</span>\n        System.out.println(<span class=\"hljs-string\">\"具体模板1：customOperation()\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomClass2</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractClass</span></span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">customOperation</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// 具体模板2 业务逻辑</span>\n        System.out.println(<span class=\"hljs-string\">\"具体模板2：customOperation()\"</span>);\n    }\n}\n</code></div></pre>\n<h4><a id=\"_57\"></a>回调方式</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CallBack</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">customOperation</span><span class=\"hljs-params\">()</span></span>;\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SubCallBack</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">CallBack</span></span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">customOperation</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"callback operation1...\"</span>);\n    }\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Template</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">baseOperation</span><span class=\"hljs-params\">()</span></span>{\n        System.out.println(<span class=\"hljs-string\">\"模板类公共操作\"</span>);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">templateMethod</span><span class=\"hljs-params\">(CallBack callback)</span></span>{\n        baseOperation();\n        callback.customOperation();\n    }\n}\n</code></div></pre>\n<h4><a id=\"_81\"></a>钩子函数</h4>\n<p>设计钩子方法的主要目的是干预模板方法的执行流程，使得控制行为流程更加灵活，更符合实际业务的需求。钩子方法的返回值一般为适合条件分支语句的返回值（如boolean、int等）。子类可以自行选择重写。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AbstractBasePay</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">BasePay</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mobilePay</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// 钩子函数</span>\n        <span class=\"hljs-keyword\">if</span> (isCheckAuth()) {\n            checkAuth();\n        }\n        checkParam();\n        checkRisk();\n        channlePay();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">checkParam</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"检查参数\"</span>);\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">checkAuth</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"支付权限校验\"</span>);\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">checkRisk</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"风控校验\"</span>);\n    }\n    \n    <span class=\"hljs-comment\">//渠道支付</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">channlePay</span><span class=\"hljs-params\">()</span></span>;\n    \n    <span class=\"hljs-comment\">//钩子函数，子类可以覆写，来选择手开启支付权限校验  默认不开启</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isCheckAuth</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    }\n}\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">EBankChannelPay</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractBasePay</span></span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">channlePay</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"网银支付\"</span>);\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isCheckAuth</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n}\n</code></div></pre>\n<h4><a id=\"Spring_138\"></a>Spring中的模板方法模式</h4>\n<p>在spring源码中使用到模板模式的有以下几类（<strong>在Spring中大多数模板方式都是行为接口的定义：Callback</strong>）：</p>\n<ul>\n<li><strong>RestTemplate Http Restful接口请求模板</strong></li>\n<li><strong>AsyncRestTemplate 异步Http Restful接口请求模板</strong></li>\n<li><strong>JdbcTemplate JDBC关系型数据库操作模板</strong></li>\n<li><strong>HibernateTemplate Hibernate关系型数据库操作模板</strong></li>\n<li><strong>JmsTemplate 消息队列模板</strong></li>\n<li><strong>TransactionTemplate 编程式事务模板</strong></li>\n</ul>\n<p>带有Template的基本都是模板方法模式。</p>\n<h5><a id=\"JdbcTemplate_151\"></a>JdbcTemplate</h5>\n<p>JdbcTemplate是JDBC核心软件包中的中心类。它简化了JDBC的使用，并有助于避免常见错误。它执行核心JDBC工作流程，留下应用程序代码以提供SQL并提取结果</p>\n<p>spring通过JdbcTemplate提供原生的JDBC SQL语句执行操作。JdbcTemplate和JdbcOperations均位于org.springframework.jdbc.core下.</p>\n<p>JdbcOperations提供最基本的SQL方法执行接口，JdbcTemplate负责模板方法调用。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@FunctionalInterface</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">ConnectionCallback</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>{\n    <span class=\"hljs-meta\">@Nullable</span>\n    <span class=\"hljs-function\">T <span class=\"hljs-title\">doInConnection</span><span class=\"hljs-params\">(Connection var1)</span> <span class=\"hljs-keyword\">throws</span> SQLException, DataAccessException</span>;\n}\n\n<span class=\"hljs-meta\">@Nullable</span>\n    <span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(ConnectionCallback&lt;T&gt; action)</span> <span class=\"hljs-keyword\">throws</span> DataAccessException </span>{\n        Assert.notNull(action, <span class=\"hljs-string\">\"Callback object must not be null\"</span>);\n        Connection con = DataSourceUtils.getConnection(<span class=\"hljs-keyword\">this</span>.obtainDataSource());\n\n        Object var10;\n        <span class=\"hljs-keyword\">try</span> {\n            Connection conToUse = <span class=\"hljs-keyword\">this</span>.createConnectionProxy(con);\n            var10 = action.doInConnection(conToUse);\n        } <span class=\"hljs-keyword\">catch</span> (SQLException var8) {\n            String sql = getSql(action);\n            DataSourceUtils.releaseConnection(con, <span class=\"hljs-keyword\">this</span>.getDataSource());\n            con = <span class=\"hljs-keyword\">null</span>;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">this</span>.translateException(<span class=\"hljs-string\">\"ConnectionCallback\"</span>, sql, var8);\n        } <span class=\"hljs-keyword\">finally</span> {\n            DataSourceUtils.releaseConnection(con, <span class=\"hljs-keyword\">this</span>.getDataSource());\n        }\n\n        <span class=\"hljs-keyword\">return</span> var10;\n    }\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@FunctionalInterface</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">StatementCallback</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>{\n    <span class=\"hljs-meta\">@Nullable</span>\n    <span class=\"hljs-function\">T <span class=\"hljs-title\">doInStatement</span><span class=\"hljs-params\">(Statement var1)</span> <span class=\"hljs-keyword\">throws</span> SQLException, DataAccessException</span>;\n}\n\n<span class=\"hljs-meta\">@Nullable</span>\n    <span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(StatementCallback&lt;T&gt; action)</span> <span class=\"hljs-keyword\">throws</span> DataAccessException </span>{\n        Assert.notNull(action, <span class=\"hljs-string\">\"Callback object must not be null\"</span>);\n      <span class=\"hljs-comment\">//1.获得连接  </span>\n      Connection con = DataSourceUtils.getConnection(<span class=\"hljs-keyword\">this</span>.obtainDataSource());\n        Statement stmt = <span class=\"hljs-keyword\">null</span>;\n\n        Object var11;\n        <span class=\"hljs-keyword\">try</span> {\n           <span class=\"hljs-comment\">//2.创建语句</span>\n            stmt = con.createStatement();\n            <span class=\"hljs-keyword\">this</span>.applyStatementSettings(stmt);\n          <span class=\"hljs-comment\">//3.执行语句</span>\n            T result = action.doInStatement(stmt);\n            <span class=\"hljs-keyword\">this</span>.handleWarnings(stmt);\n            var11 = result;\n        } <span class=\"hljs-keyword\">catch</span> (SQLException var9) {\n            String sql = getSql(action);\n            JdbcUtils.closeStatement(stmt);\n            stmt = <span class=\"hljs-keyword\">null</span>;\n            DataSourceUtils.releaseConnection(con, <span class=\"hljs-keyword\">this</span>.getDataSource());\n            con = <span class=\"hljs-keyword\">null</span>;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">this</span>.translateException(<span class=\"hljs-string\">\"StatementCallback\"</span>, sql, var9);\n        } <span class=\"hljs-keyword\">finally</span> {\n          <span class=\"hljs-comment\">//4.关闭语句</span>\n            JdbcUtils.closeStatement(stmt);\n          <span class=\"hljs-comment\">//5.释放连接</span>\n            DataSourceUtils.releaseConnection(con, <span class=\"hljs-keyword\">this</span>.getDataSource());\n        }\n        <span class=\"hljs-keyword\">return</span> var11;\n    }\n</code></div></pre>\n<p>子类在实现该接口时，需要实现回调接口中的<code>doInStatement</code>方法，即执行SQL的相关逻辑，这样模板方法就会因doInstatement的不同逻辑而呈现不同的功能，如查询、更新等。</p>\n');
INSERT INTO `article_body` VALUES (1048017972309786624, '### Docker架构\n\n#### 镜像和容器\n\n**镜像（image）**：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像\n\n**容器（container）**：镜像中的应用程序运行后形成的进程就是容器，只是Docker会给容器做隔离，**对外不可见**\n\n#### DockerHub\n\nDockerhub是一个docker镜像的托管平台，这样的平台称为Docker Registry。国内类似DockerHubde公开服务平台，如网易云镜像服务，阿里云镜像服务。\n\n#### Docker架构\n\nDocker是一个CS架构的程序，由两部分组成：\n\n- 服务端-server：Docker守护进程，负责处理docker指令，管理镜像，容器等】\n- 客户端-client：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令\n![Docker架构.jpg](http://rm51mx6mn.hn-bkt.clouddn.com/370425b3-2bd9-415f-a0c1-c1e18ccdf052.jpg)\n### Docker基本操作\n\n\n\n镜像名称一般分为两部分组成:`[respository]:[tag]`，在没有指定tag时，默认是latest，代表最新版本的镜像\n\n##### 镜像操作命令\n\n![](./docker/docker镜像操作命令.jpg)\n\n##### 容器相关命令\n![docker容器相关命令.jpg](http://rm51mx6mn.hn-bkt.clouddn.com/577cf0dc-c354-4cc2-9327-131184ebc997.jpg)\n```shell\ndocker exec //进入容器执行命令\ndocker logs //查看容器运行日志\ndocker ps //查看所有运行的容器及其状态\n```\n\n### 数据卷\n\n容器与数据耦合的问题\n\n- 不便于修改\n- 数据不可复用\n- 升级维护困难\n\n**数据卷（volume）**是一个虚拟目录，指向宿主机文件系统的某个目录。\n\n### 挂载数据卷\n![docker挂载.jpg](http://rm51mx6mn.hn-bkt.clouddn.com/3e5cf876-82e5-42a1-9592-fac823f3f1c4.jpg)\n1. docker run 的命令通过`-v`参数挂载文件或目录到容器中：\n   1. `-v volume名称:容器内目录`\n   2. `-v 宿主机文件:容器内文件`\n   3. `-v 宿主机目录:容器内目录`\n2. 数据卷挂载与目录直接挂载\n   - 数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找\n   - 目录挂载耦合度高，需要自己管理目录，不过容易查找位置\n\n### Docker自定义镜像\n\n**镜像**：镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。\n![docker镜像操作命令.jpg](http://rm51mx6mn.hn-bkt.clouddn.com/817347ba-1a17-422e-a437-cb001402b8da.jpg)\n镜像是分层结构，每一层称为一个layer\n\n- Baseimage层：包含基本的系统函数库、环境变量、文件系统\n- Entrypoint:入口，是镜像中应用的启动命令\n- 其他：再Baseimage基础上添加依赖、安装程序、完成整个应用的安装配置\n\n#### Dockerfile\n\n**Dockerfile**就是一个文本文件，其中包含一个个的**指令**，用指令来说明要执行什么擦欧总来构建镜像。每一个指令都会形成一层layer\n![dockerfile指令.jpg](http://rm51mx6mn.hn-bkt.clouddn.com/7c8a355b-12b8-4308-8d98-63ab4f47d68d.jpg)\n### DockerCompose\n\nDocker Compose可以基于Compose文件帮助我们快速部署分布式的应用，而无需手动一个个创建和运行容器。\n\nCompose文件是一个文本文件，通过指定定义集群中的每个容器如何运行。\n\n### Docker镜像仓库\n\n公共仓库：例如Docker官方的Docker hub，国内的网易云镜像服务，阿里巴巴镜像服务\n\n私有仓库：企业或用户自己搭建的Docker Registry\n\n1. 推送本地镜像到仓库前都必须重命名（`docker tag`）镜像，以镜像仓库地址为前缀\n2. 镜像仓库推送前需要把仓库地址配置到docker服务的daemon.json，被docker信任\n3. 推送使用`docker push`\n4. 拉取使用`docker pull`', '<h3><a id=\"Docker_0\"></a>Docker架构</h3>\n<h4><a id=\"_2\"></a>镜像和容器</h4>\n<p><strong>镜像（image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像</p>\n<p><strong>容器（container）</strong>：镜像中的应用程序运行后形成的进程就是容器，只是Docker会给容器做隔离，<strong>对外不可见</strong></p>\n<h4><a id=\"DockerHub_8\"></a>DockerHub</h4>\n<p>Dockerhub是一个docker镜像的托管平台，这样的平台称为Docker Registry。国内类似DockerHubde公开服务平台，如网易云镜像服务，阿里云镜像服务。</p>\n<h4><a id=\"Docker_12\"></a>Docker架构</h4>\n<p>Docker是一个CS架构的程序，由两部分组成：</p>\n<ul>\n<li>服务端-server：Docker守护进程，负责处理docker指令，管理镜像，容器等】</li>\n<li>客户端-client：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令<br />\n<img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/370425b3-2bd9-415f-a0c1-c1e18ccdf052.jpg\" alt=\"Docker架构.jpg\" /></li>\n</ul>\n<h3><a id=\"Docker_19\"></a>Docker基本操作</h3>\n<p>镜像名称一般分为两部分组成:<code>[respository]:[tag]</code>，在没有指定tag时，默认是latest，代表最新版本的镜像</p>\n<h5><a id=\"_25\"></a>镜像操作命令</h5>\n<p><img src=\"./docker/docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4.jpg\" alt=\"\" /></p>\n<h5><a id=\"_29\"></a>容器相关命令</h5>\n<p><img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/577cf0dc-c354-4cc2-9327-131184ebc997.jpg\" alt=\"docker容器相关命令.jpg\" /></p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker exec //进入容器执行命令\ndocker logs //查看容器运行日志\ndocker ps //查看所有运行的容器及其状态\n</code></div></pre>\n<h3><a id=\"_37\"></a>数据卷</h3>\n<p>容器与数据耦合的问题</p>\n<ul>\n<li>不便于修改</li>\n<li>数据不可复用</li>\n<li>升级维护困难</li>\n</ul>\n<p>**数据卷（volume）**是一个虚拟目录，指向宿主机文件系统的某个目录。</p>\n<h3><a id=\"_47\"></a>挂载数据卷</h3>\n<p><img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/3e5cf876-82e5-42a1-9592-fac823f3f1c4.jpg\" alt=\"docker挂载.jpg\" /></p>\n<ol>\n<li>docker run 的命令通过<code>-v</code>参数挂载文件或目录到容器中：\n<ol>\n<li><code>-v volume名称:容器内目录</code></li>\n<li><code>-v 宿主机文件:容器内文件</code></li>\n<li><code>-v 宿主机目录:容器内目录</code></li>\n</ol>\n</li>\n<li>数据卷挂载与目录直接挂载\n<ul>\n<li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li>\n<li>目录挂载耦合度高，需要自己管理目录，不过容易查找位置</li>\n</ul>\n</li>\n</ol>\n<h3><a id=\"Docker_57\"></a>Docker自定义镜像</h3>\n<p><strong>镜像</strong>：镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。<br />\n<img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/817347ba-1a17-422e-a437-cb001402b8da.jpg\" alt=\"docker镜像操作命令.jpg\" /><br />\n镜像是分层结构，每一层称为一个layer</p>\n<ul>\n<li>Baseimage层：包含基本的系统函数库、环境变量、文件系统</li>\n<li>Entrypoint:入口，是镜像中应用的启动命令</li>\n<li>其他：再Baseimage基础上添加依赖、安装程序、完成整个应用的安装配置</li>\n</ul>\n<h4><a id=\"Dockerfile_67\"></a>Dockerfile</h4>\n<p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的<strong>指令</strong>，用指令来说明要执行什么擦欧总来构建镜像。每一个指令都会形成一层layer<br />\n<img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/7c8a355b-12b8-4308-8d98-63ab4f47d68d.jpg\" alt=\"dockerfile指令.jpg\" /></p>\n<h3><a id=\"DockerCompose_71\"></a>DockerCompose</h3>\n<p>Docker Compose可以基于Compose文件帮助我们快速部署分布式的应用，而无需手动一个个创建和运行容器。</p>\n<p>Compose文件是一个文本文件，通过指定定义集群中的每个容器如何运行。</p>\n<h3><a id=\"Docker_77\"></a>Docker镜像仓库</h3>\n<p>公共仓库：例如Docker官方的Docker hub，国内的网易云镜像服务，阿里巴巴镜像服务</p>\n<p>私有仓库：企业或用户自己搭建的Docker Registry</p>\n<ol>\n<li>推送本地镜像到仓库前都必须重命名（<code>docker tag</code>）镜像，以镜像仓库地址为前缀</li>\n<li>镜像仓库推送前需要把仓库地址配置到docker服务的daemon.json，被docker信任</li>\n<li>推送使用<code>docker push</code></li>\n<li>拉取使用<code>docker pull</code></li>\n</ol>\n');
INSERT INTO `article_body` VALUES (1048019308057198592, '## 什么是Java Annotation\n\nAnnotation是从JDK5.0开始引入的新技术。\n\n## Annotation的作用\n\n- 不是程序本身，可以对程序作出解释。\n- 可以被其他程序（比如编译器）读取\n\n## Annotationd的格式\n\n注解是以\"@注解名\"在代码中存在的，还可以添加一些参数值。例如@SuppressWarning(value=\"unchecked\")\n\n## Annotation在哪里使用\n\n可以在package、class、method、filed等等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。\n\n## Java内置注解\n\n__@Override__：定义在Java.lang.Override中，此注解只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法。\n\n__@Deprecated__：定义在Java.lang.Deprecated中，此注解可以用于修辞方法，属性，类，不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择。\n\n__@SuppressWarnings__：定义在Java.lang.SuppressWarnings中，用来抑制编译时的警告信息。需要添加一个参数才能使用。\n\n## 元注解\n\n元注解的作用就是负责注解其他的注解。Java定义了4个标准的meta-annotation类型，他们被用来提供对其他注解类型的说明。这些类型和它们所支持的类在Java.lang.annotation包中可以找到\n\n- __@Target__：描述注解使用的范围。\n- __@Retention__：表示需要在什么级别保存该注释信息，用于描述注解的声明周期。（SOURCE<CLASS<RUNTIME）\n- __@Documented__:说明该注解将包含在javadoc中\n- __@Inherited__:说明子类可以继承父类中的该注解\n\n## 自定义注解\n\n使用__@Interface__自定义注解时，自动继承了__java.lang.annotation.Annotation__接口\n\n分析：\n\n- __@Interface__用来声明一个注解，格式：public @Interface 注解名 {定义内容}\n- 其中的每一个方法实际上时声明了一个配置参数。\n- 方法的名称就是参数的名称、\n-  返回值类型就是参数的类型（返回值只能是基本类型，Class，String，enum）\n- 可以通过default来声明参数的默认值\n- 如果只有一个参数成员，一般参数名为value\n- 注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值。', '<h2><a id=\"Java_Annotation_0\"></a>什么是Java Annotation</h2>\n<p>Annotation是从JDK5.0开始引入的新技术。</p>\n<h2><a id=\"Annotation_4\"></a>Annotation的作用</h2>\n<ul>\n<li>不是程序本身，可以对程序作出解释。</li>\n<li>可以被其他程序（比如编译器）读取</li>\n</ul>\n<h2><a id=\"Annotationd_9\"></a>Annotationd的格式</h2>\n<p>注解是以&quot;@注解名&quot;在代码中存在的，还可以添加一些参数值。例如@SuppressWarning(value=“unchecked”)</p>\n<h2><a id=\"Annotation_13\"></a>Annotation在哪里使用</h2>\n<p>可以在package、class、method、filed等等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。</p>\n<h2><a id=\"Java_17\"></a>Java内置注解</h2>\n<p><strong>@Override</strong>：定义在Java.lang.Override中，此注解只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法。</p>\n<p><strong>@Deprecated</strong>：定义在Java.lang.Deprecated中，此注解可以用于修辞方法，属性，类，不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择。</p>\n<p><strong>@SuppressWarnings</strong>：定义在Java.lang.SuppressWarnings中，用来抑制编译时的警告信息。需要添加一个参数才能使用。</p>\n<h2><a id=\"_25\"></a>元注解</h2>\n<p>元注解的作用就是负责注解其他的注解。Java定义了4个标准的meta-annotation类型，他们被用来提供对其他注解类型的说明。这些类型和它们所支持的类在Java.lang.annotation包中可以找到</p>\n<ul>\n<li><strong>@Target</strong>：描述注解使用的范围。</li>\n<li><strong>@Retention</strong>：表示需要在什么级别保存该注释信息，用于描述注解的声明周期。（SOURCE&lt;CLASS&lt;RUNTIME）</li>\n<li><strong>@Documented</strong>:说明该注解将包含在javadoc中</li>\n<li><strong>@Inherited</strong>:说明子类可以继承父类中的该注解</li>\n</ul>\n<h2><a id=\"_34\"></a>自定义注解</h2>\n<p>使用__@Interface__自定义注解时，自动继承了__java.lang.annotation.Annotation__接口</p>\n<p>分析：</p>\n<ul>\n<li>__@Interface__用来声明一个注解，格式：public @Interface 注解名 {定义内容}</li>\n<li>其中的每一个方法实际上时声明了一个配置参数。</li>\n<li>方法的名称就是参数的名称、</li>\n<li>返回值类型就是参数的类型（返回值只能是基本类型，Class，String，enum）</li>\n<li>可以通过default来声明参数的默认值</li>\n<li>如果只有一个参数成员，一般参数名为value</li>\n<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值。</li>\n</ul>\n');
INSERT INTO `article_body` VALUES (1048026009816793088, '## Java反射机制概述\n\n### 动态语言\n\n是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或者其他结构上的变化。通俗的说就是在运行时可以根据某些条件改变其自身结构。\n\n例如：Object-C、C#、JavaScript、PHP、Python\n\n### 静态语言\n\n与动态语言相比，运行时结构不可变的语言就是静态语言。如Java，C，C++\n\nJava不是动态用语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用Java反射机制获得类似动态语言的特性。Java的动态性让编程更加灵活。\n\n## Java Reflection\n\nReflection（反射）时Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。\n\n加载完类之后，在__堆内存的方法区__中就产生了一个__Class类型__的对象（一个类只有一个Class对象），这个Class对象就包含了__类的完整结构信息__，我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的内部结构，所以形象的称之为__反射__。\n\n## Java反射提供的功能\n\n1. 运行时判断任意一个对象所属的类\n2. 运行时构造任意一个类的对象\n3. 运行时判断任意一个类所具有的成员变量和方法\n4. 运行时获取泛型信息\n5. 运行时调用任意一个对象的成员变量和方法\n6. 运行时处理注解\n7. 生成动态代理\n8. ...\n\n#### 优点：\n\n可以实现动态创建对象和编译，体现出很大的灵活性\n\n#### 缺点：\n\n对性能有影响。使用反射机制基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。\n\n## 反射相关的API\n\n__java.lang.Class__:代表一个类\n\n__java.lang.reflect.Field__:代表类的成员变量\n\n__java.lang.reflect.Method__:代表类的成员方法\n\n__java.lang.reflect.Constructor__:代表类的构造器\n\n## Class类\n\n对象照镜子后可以得到的信息：某个类的__属性__、__方法__、和__构造器__、某个类到底实现了哪些__接口__。\n\n对于每个类而言，JRE都为其保留了一个不变的Class类型的对象。一个Class对象包含了特定的某个结构的有关信息。\n\n- Class本身是一个类\n- Class对象只能由系统建立\n- 一个加载的类在JVM中只会有一个Class实例\n- 一个Class对象对应的是一个加载到JVM中的一个.class文件\n- 每个类的实例都会记得自己是有哪个Class实例所生成\n- 通过Class可以完整地得到一个类中的所有被加载的结构\n- Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象，\n\n### Class类的常用方法\n![Class类常用方法.jpg](http://rm51mx6mn.hn-bkt.clouddn.com/31a5ab7d-be28-4a0f-877e-143b3761e2f0.jpg)\n### 获取Class类的实例\n![获得Class类的实例.png](http://rm51mx6mn.hn-bkt.clouddn.com/d7a4d3f8-e178-42da-9a7b-7a6d634502c4.png)\n### 哪些类型可以有Class对象\n\n__class__：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类\n\n__interface__：接口\n\n__[]__:数组\n\n__enum__：枚举\n\n__annotation__：注解\n\n__primitive type__：基本数据类型\n\n__void__\n\n## 类加载内存分析\n\nJava内存\n\n- 堆：存放new的对象和数组，可以被所有线程共享，不会存放别的对象引用\n\n- 栈：\n\n  - 存放基本变量类型（包括这个基本类型的数值）\n  - 引用对象的变量（存放这个引用在堆里面的具体地址）\n\n- 方法区：\n\n  - 可以被所有的线程共享\n  - 包含了所有的class和static变量\n\n  \n\n### 类的加载过程\n![类加载过程.jpg](http://rm51mx6mn.hn-bkt.clouddn.com/a1392d84-3b06-476d-bb60-8ff699186086.jpg)\n#### 加载\n\n将class文件字节码内容加载到__内存__中，并将这些__静态数据__转换成__方法区__的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象。\n\n#### 链接\n\n将__Java类的二进制代码__合并到JVM的运行状态之中的过程\n\n##### 验证\n\n确保加载的类信息符合JVM规范，没有安全方面的问题\n\n##### 准备\n\n正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都在方法区中进行分配\n\n##### 解析\n\n虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程\n\n#### 初始化\n\n执行类构造器方法的过程，类构造器方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）\n\n当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先初始化父类\n\n虚拟机会保证一个类的类构造器方法在多线程环境中被正确的加锁和同步\n\n#### 什么时候会发生类的初始化\n\n##### 类的主动引用——一定会发生类的初始化\n\n- 当虚拟机启动，先初始化main方法所在的类\n- new一个类的对象\n- 调用类的静态成员（除了final常量）和静态方法\n- 使用java.lang.reflect包的方法对类进行反射调用\n- 当初始化一个类时，如果其父类没有被初始化，则先会初始化它的父类\n\n##### 类的被动引用——不会发生类的初始化\n\n- 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化\n- 通过数组定义类的引用，不会触发类的初始化\n- 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池了）\n\n### 类加载器的作用\n\n将class文件字节码内容加载到__内存__中，并将这些静态数据转换成方法区的运行时数据结构，然后再堆中生成一个代表这个类的Java.lang.Class对象，作为方法区中类数据的访问入口。\n\n__类缓存__：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，他将维持加载（缓存）一段时间。不过JVM的垃圾回收机制可以回收这些Class对象。\n\nJVM定义了如下类型的类加载器：\n#### 引导类加载器\n\n用C++编写，是JVM自带的类加载器，负责__Java平台核心库__，用来装载核心类库。该加载器无法直接获取。\n\n#### 扩展类加载器\n\n负责__jre/lib/ext下__的jar包或java.ext.dirs指定目录下的jar包装入工作库\n\n#### 系统类加载器\n\n负责__java-classpath__或者java.class.path所指的目录下的类与Jar包转入工作，是最常用的类加载器。\n\n## 获取运行时类的完整结构\n\n通过反射获取运行时类的完整结构：__Field Method Constructor Superclass Interface Annotation__\n\n获得类名：__getName() getSimpleName()__\n\n获得属性：__getFields()__;只能找到public属性\n\n​					__getDeclaredField()__;获得所有属性\n\n获得方法：__getMethod()__;获得本类和父类的所有public方法\n\n​					__getDeclaredMethod()__;获得本类的所有方法\n\n​					\n\n获得指定的构造器：__getConstructor()__ 获得public的构造方法\n\n​								  __getDeclaredConstructor()__ 获得所有的构造方法\n\n获得注解：__getAnnotations()__\n\n​					__getAnnotation()__获得指定的注解', '<h2><a id=\"Java_0\"></a>Java反射机制概述</h2>\n<h3><a id=\"_2\"></a>动态语言</h3>\n<p>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或者其他结构上的变化。通俗的说就是在运行时可以根据某些条件改变其自身结构。</p>\n<p>例如：Object-C、C#、JavaScript、PHP、Python</p>\n<h3><a id=\"_8\"></a>静态语言</h3>\n<p>与动态语言相比，运行时结构不可变的语言就是静态语言。如Java，C，C++</p>\n<p>Java不是动态用语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用Java反射机制获得类似动态语言的特性。Java的动态性让编程更加灵活。</p>\n<h2><a id=\"Java_Reflection_14\"></a>Java Reflection</h2>\n<p>Reflection（反射）时Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>\n<p>加载完类之后，在__堆内存的方法区__中就产生了一个__Class类型__的对象（一个类只有一个Class对象），这个Class对象就包含了__类的完整结构信息__，我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的内部结构，所以形象的称之为__反射__。</p>\n<h2><a id=\"Java_20\"></a>Java反射提供的功能</h2>\n<ol>\n<li>运行时判断任意一个对象所属的类</li>\n<li>运行时构造任意一个类的对象</li>\n<li>运行时判断任意一个类所具有的成员变量和方法</li>\n<li>运行时获取泛型信息</li>\n<li>运行时调用任意一个对象的成员变量和方法</li>\n<li>运行时处理注解</li>\n<li>生成动态代理</li>\n<li>…</li>\n</ol>\n<h4><a id=\"_31\"></a>优点：</h4>\n<p>可以实现动态创建对象和编译，体现出很大的灵活性</p>\n<h4><a id=\"_35\"></a>缺点：</h4>\n<p>对性能有影响。使用反射机制基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p>\n<h2><a id=\"API_39\"></a>反射相关的API</h2>\n<p><strong>java.lang.Class</strong>:代表一个类</p>\n<p><strong>java.lang.reflect.Field</strong>:代表类的成员变量</p>\n<p><strong>java.lang.reflect.Method</strong>:代表类的成员方法</p>\n<p><strong>java.lang.reflect.Constructor</strong>:代表类的构造器</p>\n<h2><a id=\"Class_49\"></a>Class类</h2>\n<p>对象照镜子后可以得到的信息：某个类的__属性__、<strong>方法</strong>、和__构造器__、某个类到底实现了哪些__接口__。</p>\n<p>对于每个类而言，JRE都为其保留了一个不变的Class类型的对象。一个Class对象包含了特定的某个结构的有关信息。</p>\n<ul>\n<li>Class本身是一个类</li>\n<li>Class对象只能由系统建立</li>\n<li>一个加载的类在JVM中只会有一个Class实例</li>\n<li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li>\n<li>每个类的实例都会记得自己是有哪个Class实例所生成</li>\n<li>通过Class可以完整地得到一个类中的所有被加载的结构</li>\n<li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象，</li>\n</ul>\n<h3><a id=\"Class_63\"></a>Class类的常用方法</h3>\n<p><img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/31a5ab7d-be28-4a0f-877e-143b3761e2f0.jpg\" alt=\"Class类常用方法.jpg\" /></p>\n<h3><a id=\"Class_65\"></a>获取Class类的实例</h3>\n<p><img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/d7a4d3f8-e178-42da-9a7b-7a6d634502c4.png\" alt=\"获得Class类的实例.png\" /></p>\n<h3><a id=\"Class_67\"></a>哪些类型可以有Class对象</h3>\n<p><strong>class</strong>：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</p>\n<p><strong>interface</strong>：接口</p>\n<p><strong>[]</strong>:数组</p>\n<p><strong>enum</strong>：枚举</p>\n<p><strong>annotation</strong>：注解</p>\n<p><strong>primitive type</strong>：基本数据类型</p>\n<p><strong>void</strong></p>\n<h2><a id=\"_83\"></a>类加载内存分析</h2>\n<p>Java内存</p>\n<ul>\n<li>\n<p>堆：存放new的对象和数组，可以被所有线程共享，不会存放别的对象引用</p>\n</li>\n<li>\n<p>栈：</p>\n<ul>\n<li>存放基本变量类型（包括这个基本类型的数值）</li>\n<li>引用对象的变量（存放这个引用在堆里面的具体地址）</li>\n</ul>\n</li>\n<li>\n<p>方法区：</p>\n<ul>\n<li>可以被所有的线程共享</li>\n<li>包含了所有的class和static变量</li>\n</ul>\n</li>\n</ul>\n<h3><a id=\"_101\"></a>类的加载过程</h3>\n<p><img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/a1392d84-3b06-476d-bb60-8ff699186086.jpg\" alt=\"类加载过程.jpg\" /></p>\n<h4><a id=\"_103\"></a>加载</h4>\n<p>将class文件字节码内容加载到__内存__中，并将这些__静态数据__转换成__方法区__的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象。</p>\n<h4><a id=\"_107\"></a>链接</h4>\n<p>将__Java类的二进制代码__合并到JVM的运行状态之中的过程</p>\n<h5><a id=\"_111\"></a>验证</h5>\n<p>确保加载的类信息符合JVM规范，没有安全方面的问题</p>\n<h5><a id=\"_115\"></a>准备</h5>\n<p>正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都在方法区中进行分配</p>\n<h5><a id=\"_119\"></a>解析</h5>\n<p>虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程</p>\n<h4><a id=\"_123\"></a>初始化</h4>\n<p>执行类构造器方法的过程，类构造器方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）</p>\n<p>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先初始化父类</p>\n<p>虚拟机会保证一个类的类构造器方法在多线程环境中被正确的加锁和同步</p>\n<h4><a id=\"_131\"></a>什么时候会发生类的初始化</h4>\n<h5><a id=\"_133\"></a>类的主动引用——一定会发生类的初始化</h5>\n<ul>\n<li>当虚拟机启动，先初始化main方法所在的类</li>\n<li>new一个类的对象</li>\n<li>调用类的静态成员（除了final常量）和静态方法</li>\n<li>使用java.lang.reflect包的方法对类进行反射调用</li>\n<li>当初始化一个类时，如果其父类没有被初始化，则先会初始化它的父类</li>\n</ul>\n<h5><a id=\"_141\"></a>类的被动引用——不会发生类的初始化</h5>\n<ul>\n<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化</li>\n<li>通过数组定义类的引用，不会触发类的初始化</li>\n<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池了）</li>\n</ul>\n<h3><a id=\"_147\"></a>类加载器的作用</h3>\n<p>将class文件字节码内容加载到__内存__中，并将这些静态数据转换成方法区的运行时数据结构，然后再堆中生成一个代表这个类的Java.lang.Class对象，作为方法区中类数据的访问入口。</p>\n<p><strong>类缓存</strong>：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，他将维持加载（缓存）一段时间。不过JVM的垃圾回收机制可以回收这些Class对象。</p>\n<p>JVM定义了如下类型的类加载器：</p>\n<h4><a id=\"_154\"></a>引导类加载器</h4>\n<p>用C++编写，是JVM自带的类加载器，负责__Java平台核心库__，用来装载核心类库。该加载器无法直接获取。</p>\n<h4><a id=\"_158\"></a>扩展类加载器</h4>\n<p>负责__jre/lib/ext下__的jar包或java.ext.dirs指定目录下的jar包装入工作库</p>\n<h4><a id=\"_162\"></a>系统类加载器</h4>\n<p>负责__java-classpath__或者java.class.path所指的目录下的类与Jar包转入工作，是最常用的类加载器。</p>\n<h2><a id=\"_166\"></a>获取运行时类的完整结构</h2>\n<p>通过反射获取运行时类的完整结构：<strong>Field Method Constructor Superclass Interface Annotation</strong></p>\n<p>获得类名：<strong>getName() getSimpleName()</strong></p>\n<p>获得属性：<strong>getFields()</strong>;只能找到public属性</p>\n<p>​					<strong>getDeclaredField()</strong>;获得所有属性</p>\n<p>获得方法：<strong>getMethod()</strong>;获得本类和父类的所有public方法</p>\n<p>​					<strong>getDeclaredMethod()</strong>;获得本类的所有方法</p>\n<p>​</p>\n<p>获得指定的构造器：<strong>getConstructor()</strong> 获得public的构造方法</p>\n<p>​								  <strong>getDeclaredConstructor()</strong> 获得所有的构造方法</p>\n<p>获得注解：<strong>getAnnotations()</strong></p>\n<p>​					__getAnnotation()__获得指定的注解</p>\n');
INSERT INTO `article_body` VALUES (1048027135333105664, '## Nacos\n\n### 服务注册到Nacos\n\n1. 在cloud-demo父工程中添加`spring-cloud-alibaba`的管理依赖\n2. 注释掉orderservice和userservice中原有的erureka依赖\n3. 添加nacos客户端依赖\n\n### Nacos服务分级存储模型\n\n服务 集群 实例\n![Nacos集群.jpg](http://rm51mx6mn.hn-bkt.clouddn.com/39f4647a-2570-470d-9c48-8a7282776d2f.jpg)\n服务调用尽可能选择本地集群的服务，跨集群调用延迟较高，本地集群不可访问是，再去访问其他集群。\n\n  \n\n### NacosRule负载均衡策略\n\n优先选择本地集群，在本地集群中随机选择，本地没有服务才会跨集群。\n\nNacos提供了权重负载均衡：在Nacos控制台可以设置实例的权重值，选中实例后面的编辑按钮。权重为0不会被访问。可以做到平滑升级服务。\n\n### 环境隔离\n\n**Namespace**：Nacos中**服务存储**和**数据存储**的最外层都是一个名为namespace的东西，用来做最外层隔离。不同命名空间的实例不可见。\n\n### 临时实例和非临时实例\n\n服务注册到Nacos时，可以选择注册为临时或者非临时实例。\n\n### Nacos配置管理\n\n#### 统一配置管理\n\n- 配置更改热更新\n\n配置获取步骤如下：\n![Nacos配置获取步骤.jpg](http://rm51mx6mn.hn-bkt.clouddn.com/7c9c47d6-33a4-496d-a0fa-91e2b3f1206f.jpg)\n\n#### 将服务交给Nacos管理的步骤\n\n1. 在Nacos中添加配置文件\n2. 在微服务中引入nacos的config依赖\n3. 在微服务中添加bootstrap.yml，配置nacos地址，当前环境、服务名称、文件后缀名。这些决定了程序启动时去读取nacos的哪个配置文件\n\n#### 配置热更新\n\nNacos配置文件变更后，微服务无需重写启动就可以感知。需要配置：\n\n方式一：在`@value`注入的变量所在**类**上添加注解`@RefreshScope`\n\n方式二：使用`@ConfigurationProperties`注解（**推荐**）\n\n#### 多环境配置共享\n\n- 微服务启动时会从nacos读取多个配置文件\n  1. 服务名-环境.yaml\n  2. 服务名.yaml\n\n无论profile如何变化，服务名.yaml这个文件一定会加载，因此多环境共享配置可以写入这个文件。\n\n多种配置文件优先级：\n\n服务名-profile.yaml>服务名.yaml>本地配置\n\n#### Nacos集群搭建\n\n基本步骤：\n\n- 搭建数据库，初始化数据库表结构\n- 下载Nacos安装包\n- 配置Nacos\n- 启动nacos集群\n- nginx反向代理', '<h2><a id=\"Nacos_0\"></a>Nacos</h2>\n<h3><a id=\"Nacos_2\"></a>服务注册到Nacos</h3>\n<ol>\n<li>在cloud-demo父工程中添加<code>spring-cloud-alibaba</code>的管理依赖</li>\n<li>注释掉orderservice和userservice中原有的erureka依赖</li>\n<li>添加nacos客户端依赖</li>\n</ol>\n<h3><a id=\"Nacos_8\"></a>Nacos服务分级存储模型</h3>\n<p>服务 集群 实例<br />\n<img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/39f4647a-2570-470d-9c48-8a7282776d2f.jpg\" alt=\"Nacos集群.jpg\" /><br />\n服务调用尽可能选择本地集群的服务，跨集群调用延迟较高，本地集群不可访问是，再去访问其他集群。</p>\n<h3><a id=\"NacosRule_16\"></a>NacosRule负载均衡策略</h3>\n<p>优先选择本地集群，在本地集群中随机选择，本地没有服务才会跨集群。</p>\n<p>Nacos提供了权重负载均衡：在Nacos控制台可以设置实例的权重值，选中实例后面的编辑按钮。权重为0不会被访问。可以做到平滑升级服务。</p>\n<h3><a id=\"_22\"></a>环境隔离</h3>\n<p><strong>Namespace</strong>：Nacos中<strong>服务存储</strong>和<strong>数据存储</strong>的最外层都是一个名为namespace的东西，用来做最外层隔离。不同命名空间的实例不可见。</p>\n<h3><a id=\"_26\"></a>临时实例和非临时实例</h3>\n<p>服务注册到Nacos时，可以选择注册为临时或者非临时实例。</p>\n<h3><a id=\"Nacos_30\"></a>Nacos配置管理</h3>\n<h4><a id=\"_32\"></a>统一配置管理</h4>\n<ul>\n<li>配置更改热更新</li>\n</ul>\n<p>配置获取步骤如下：<br />\n<img src=\"http://rm51mx6mn.hn-bkt.clouddn.com/7c9c47d6-33a4-496d-a0fa-91e2b3f1206f.jpg\" alt=\"Nacos配置获取步骤.jpg\" /></p>\n<h4><a id=\"Nacos_39\"></a>将服务交给Nacos管理的步骤</h4>\n<ol>\n<li>在Nacos中添加配置文件</li>\n<li>在微服务中引入nacos的config依赖</li>\n<li>在微服务中添加bootstrap.yml，配置nacos地址，当前环境、服务名称、文件后缀名。这些决定了程序启动时去读取nacos的哪个配置文件</li>\n</ol>\n<h4><a id=\"_45\"></a>配置热更新</h4>\n<p>Nacos配置文件变更后，微服务无需重写启动就可以感知。需要配置：</p>\n<p>方式一：在<code>@value</code>注入的变量所在<strong>类</strong>上添加注解<code>@RefreshScope</code></p>\n<p>方式二：使用<code>@ConfigurationProperties</code>注解（<strong>推荐</strong>）</p>\n<h4><a id=\"_53\"></a>多环境配置共享</h4>\n<ul>\n<li>微服务启动时会从nacos读取多个配置文件\n<ol>\n<li>服务名-环境.yaml</li>\n<li>服务名.yaml</li>\n</ol>\n</li>\n</ul>\n<p>无论profile如何变化，服务名.yaml这个文件一定会加载，因此多环境共享配置可以写入这个文件。</p>\n<p>多种配置文件优先级：</p>\n<p>服务名-profile.yaml&gt;服务名.yaml&gt;本地配置</p>\n<h4><a id=\"Nacos_65\"></a>Nacos集群搭建</h4>\n<p>基本步骤：</p>\n<ul>\n<li>搭建数据库，初始化数据库表结构</li>\n<li>下载Nacos安装包</li>\n<li>配置Nacos</li>\n<li>启动nacos集群</li>\n<li>nginx反向代理</li>\n</ul>\n');
INSERT INTO `article_body` VALUES (1048028956206301184, '### 如果不是他打篮球我还真不认识他\n\n这句话无论是在微博、贴吧或者B站都能看到。\n\n一句“**大家好，我是练习时长两年半的个人练习生蔡徐坤**”再加上一段运球视频，经过加工、修改，使其丑化，最后转载，发送，如同蝗虫般肆虐着大部分网络平台。\n\n### 这些充斥着恶趣味的视频及图片，便逐渐成为网友认识蔡徐坤的重要途经。\n\n至此，与朋友结伴打球时，欢声笑语中少不了那句“**你打球真像蔡徐坤**”；浏览B站时，林林总总的推广视频里少不了跟随”鸡你太美“音乐运球的鬼畜视频；甚至微信中更是衍生出一批恶搞表情包。\n\n我们每一个网民没有义务与责任做到具体细致地了解蔡徐坤，\n\n而这也使得大部分网民认识蔡徐坤的途径局限于以上，如B站的鬼畜视频。\n\n笔者也是打篮球的人，也热爱这项体育项目。说实在的，当笔者第一次看到他运球的那个视频时，笔者同样表示其技术不敢恭维，再看到后面略显魔性的舞蹈，更是笑得前仰后合（甚至有点莫名的害怕）。\n\n关了视频，笔者冷静片刻，发现这个被人疯转的视频也没什么了不起的\n\n每个篮球场都有水平不同的队友或对手，每个篮球大神都是从简单的喜爱，再加上后天的刻苦训练，才能达到傲人的高度。\n\n### 蔡徐坤只是喜欢篮球，并不是篮球运动员，更没有昧着良心谎称其球技有多么的高超。\n\n喜欢，并不代表他一定要具备喜欢事物的专业性，不代表他一定能拥有这项技能。他喜欢篮球，但并不代表他能拥有高强的球技。\n\n就像笔者喜欢女生，但笔者就一定有熟练的泡妞技巧吗？就一定有女朋友吗？咳咳。\n\n有趣的是\n\n### 其实这道理大伙心里都懂，但就是埋心底不肯公诸于世，为什么？\n\n为了玩梗，\n\n大部分人都喜欢玩梗，你不玩梗，就没有共同话题，你在自己的圈子里便显得很落后。\n\n因为你并不能保证你所做的每件事情都能产生共同语言。\n\n想象一下，你与小伙伴聊天，你玩过的游戏他没玩过，他看过的电视剧你没看过，一瞬间，双方陷入了沉默的尴尬气氛中。就在这时你说了句：“你知道蔡徐坤吗？”“哦哦我知道，鸡你太美！”气氛瞬间就活跃了起来。\n\n于是蔡徐坤便逐渐被用这种方式不断地“展现”在我们面前，成为了我们调侃与玩笑。\n\n### 把当红热点当梗，不断广泛用于交际之中。\n\n可以说这种做法逐渐成为了我们当代人社会交际的惯用手段，一句“鸡你太美”便可以当成打开聊天匣子的金钥匙，许多人看中了这点，便疯狂地使用梗，与人谈天说地。\n\n但是，梗，是可以夹带私货的，也就是夹带说梗人的思想。\n\n任何一句话，用不同的声音发出，思想感情都可以相差甚远。如同：\n\n你在球场打球，忽然你的朋友从旁边窜出来，捂着肚子讥笑道：“你打球好菜啊，就像蔡徐坤。”你在那听着，不生气，因为你知道这是玩笑话，\n\n但心里已经给这句话，这个梗定义为：打球技术差=蔡徐坤；更有甚者解析过度形成：任何坏的事物=蔡徐坤......\n\n就这样，蔡徐坤作为我们饭后调侃，游戏玩笑，带着每个人对别人的讥讽，嘲笑越传越广.......\n\n至此，大部分网民在心中都被烙下：差劲=蔡徐坤 这样一种刻板印象。\n\n但可笑的是\n\n大部分玩这个梗的人，连最熟悉的那句“全面制作人你们好，我是练习时长两年半的个人练习生，蔡徐坤。”中的“个人练习生”的含义是什么，“时长两年半”的概念是什么都不知道。\n\n可能你会说：哎笔者你刚还不是说我们没有义务与责任了解他吗？那我们不知道含义也没什么吧。\n\n是的，\n\n### 我们没有义务去了解一个被全网追着抹黑的他，\n\n### 我们没有责任去关心一个整天活在谩骂，人格侮辱的他，\n\n我们甚至连基本的尊重都没有给一个仅21周岁的他，\n\n就是这样，很多人把自己的无知当成理所当然，毫无节制的，毫无下限的诋毁！谩骂！\n\n笔者反问一句：他有义务与责任来承受这些侮辱与谩骂吗？\n\n注意这里是谩骂与侮辱，而非批评，而非具备逻辑与事实的批评！\n\n笔者知道你们懒，帮你们找了个人练习生背后的含义：\n\n个人练习生是指没有签约经纪公司的练习生，自己浏览资料进行练习，自行报名参加各种选秀节目，获得一定的曝光率之后可能会收到经纪公司的洽谈，决百定是否与公司签约。\n这是什么意思，意思是他没有靠山，身后空无一人......\n\n众所周知，一个明星的背后，都是有资本操控的，大家平常说的炒作就是其运作而生的。\n\n不会公关，不会运营，没有强大成熟的作业团队，单枪匹马地杀入最复杂的娱乐圈，企图能分到一杯羹。\n\n这背后是一个二十岁青年的热血与野心，他的胆量绝非屏幕后每个键盘侠可比拟的！\n\n在这里笔者不打算寻找图片，文章举例他的善举，因为有好的就会有坏的。笔者在这拿出他做好事的图文，某些人便会拿出他犯错的图文。\n\n> 人无完人，谁能保证自己绝不犯错，圣贤都不敢说。\n\n别跟我说谁谁谁就没有像蔡徐坤一样做错事，背后资本运作，银幕呈现前的剪辑，某些明星不过是靠这些掩人耳目。但蔡徐坤当时没有啊，连工作室都只有三四个并不是很强的人，不熟悉公关的前提下，他只能任人摆布。\n\n就像那句：坏人之所以是坏人，是因为，他被抓住了........\n\n他可不见得比那些明星差。\n\n“娘的要命，亏还是个男的。”“他这样打篮球，就是在侮辱篮球。”“歌欣赏不来，唱的什么玩意。”等等这些，笔者只要打开网络平台搜索关于他的东西，这些言论铺天盖地，随处可见。\n\n笔者不想也不能对这些言论加以评价与干涉，每个人都有权发出声音，表达自己的思想与看法，如同笔者现在这篇小文一样。\n\n网友的评论是必须存在的，无论褒贬。\n\n他不可能取悦每一个人，他不可能做到完美，不可能面面俱到，他会犯错，他会迷茫。\n\n这是蔡徐坤必须面对的，没有任何商量的余地。\n\n如果一个明星一点错误都不犯，网上的声音全都是无节制的赞扬，那这个明星背后的资本是有多强啊.......\n\n### 所以网民可以批评，可以指责和追究，\n### \n但在低龄化趋势的网络大环境下，某些评论真的不堪入目。\n\n笔者为此专门搜索相关微博与贴吧，里面的言论与图片，简直可怖之极。有遗像，有棺材，各种祷求他丧失性命的言论等等，这些甚至波及家人........\n\n笔者知道还有更丧尽天良的言论，笔者知道还有毫无下限的图片，笔者知道你们想看，也知道放上图片你们也许会为此感到愤怒，进而使文章更有说服力。\n\n但笔者真的对这些言论与图片连直视的勇气都没有，笔者不可能放一些自己不想看的东西进文章里面。\n\n可是，笔者可以选择不放图片进自己的文章，蔡徐坤能选择不让网友恶搞自己的图片吗？\n\n他选择不了，因为他背后力量不够。于是，他选择了法律手段。试图捍卫自己最后那点尊严，却被网友误导成了告B站，以此引发网上一片波澜。\n\n网络真的是一把锋利的双刃剑。对，双刃剑，小心点，键盘侠们。\n\n这篇小文笔者不匿名，会不会被攻击？不知道。\n\n但作为年龄相差无几的笔者，真的很佩服蔡徐坤。\n\n他有勇气，面对网上言论攻击依然坚持登台做自己喜欢做的事；\n\n他有野心，他目标非常明确，他的锋芒开辟着前进的道路；\n\n他有青稚中的成熟，他对舞台的驾驭能力与把握能力是一流的，他展现着与年龄不符的成熟与魅力；\n\n说真的，笔者很看好他，越努力越幸运这句话将会在他身上又一次验证。相信他会把网上言论当成自身垫脚石，一步步成就他的野心，实现他的梦想。\n\n（*以上皆为个人观点，码字不易，不喜.....喷吧*）', '<h3><a id=\"_0\"></a>如果不是他打篮球我还真不认识他</h3>\n<p>这句话无论是在微博、贴吧或者B站都能看到。</p>\n<p>一句“<strong>大家好，我是练习时长两年半的个人练习生蔡徐坤</strong>”再加上一段运球视频，经过加工、修改，使其丑化，最后转载，发送，如同蝗虫般肆虐着大部分网络平台。</p>\n<h3><a id=\"_6\"></a>这些充斥着恶趣味的视频及图片，便逐渐成为网友认识蔡徐坤的重要途经。</h3>\n<p>至此，与朋友结伴打球时，欢声笑语中少不了那句“<strong>你打球真像蔡徐坤</strong>”；浏览B站时，林林总总的推广视频里少不了跟随”鸡你太美“音乐运球的鬼畜视频；甚至微信中更是衍生出一批恶搞表情包。</p>\n<p>我们每一个网民没有义务与责任做到具体细致地了解蔡徐坤，</p>\n<p>而这也使得大部分网民认识蔡徐坤的途径局限于以上，如B站的鬼畜视频。</p>\n<p>笔者也是打篮球的人，也热爱这项体育项目。说实在的，当笔者第一次看到他运球的那个视频时，笔者同样表示其技术不敢恭维，再看到后面略显魔性的舞蹈，更是笑得前仰后合（甚至有点莫名的害怕）。</p>\n<p>关了视频，笔者冷静片刻，发现这个被人疯转的视频也没什么了不起的</p>\n<p>每个篮球场都有水平不同的队友或对手，每个篮球大神都是从简单的喜爱，再加上后天的刻苦训练，才能达到傲人的高度。</p>\n<h3><a id=\"_20\"></a>蔡徐坤只是喜欢篮球，并不是篮球运动员，更没有昧着良心谎称其球技有多么的高超。</h3>\n<p>喜欢，并不代表他一定要具备喜欢事物的专业性，不代表他一定能拥有这项技能。他喜欢篮球，但并不代表他能拥有高强的球技。</p>\n<p>就像笔者喜欢女生，但笔者就一定有熟练的泡妞技巧吗？就一定有女朋友吗？咳咳。</p>\n<p>有趣的是</p>\n<h3><a id=\"_28\"></a>其实这道理大伙心里都懂，但就是埋心底不肯公诸于世，为什么？</h3>\n<p>为了玩梗，</p>\n<p>大部分人都喜欢玩梗，你不玩梗，就没有共同话题，你在自己的圈子里便显得很落后。</p>\n<p>因为你并不能保证你所做的每件事情都能产生共同语言。</p>\n<p>想象一下，你与小伙伴聊天，你玩过的游戏他没玩过，他看过的电视剧你没看过，一瞬间，双方陷入了沉默的尴尬气氛中。就在这时你说了句：“你知道蔡徐坤吗？”“哦哦我知道，鸡你太美！”气氛瞬间就活跃了起来。</p>\n<p>于是蔡徐坤便逐渐被用这种方式不断地“展现”在我们面前，成为了我们调侃与玩笑。</p>\n<h3><a id=\"_40\"></a>把当红热点当梗，不断广泛用于交际之中。</h3>\n<p>可以说这种做法逐渐成为了我们当代人社会交际的惯用手段，一句“鸡你太美”便可以当成打开聊天匣子的金钥匙，许多人看中了这点，便疯狂地使用梗，与人谈天说地。</p>\n<p>但是，梗，是可以夹带私货的，也就是夹带说梗人的思想。</p>\n<p>任何一句话，用不同的声音发出，思想感情都可以相差甚远。如同：</p>\n<p>你在球场打球，忽然你的朋友从旁边窜出来，捂着肚子讥笑道：“你打球好菜啊，就像蔡徐坤。”你在那听着，不生气，因为你知道这是玩笑话，</p>\n<p>但心里已经给这句话，这个梗定义为：打球技术差=蔡徐坤；更有甚者解析过度形成：任何坏的事物=蔡徐坤…</p>\n<p>就这样，蔡徐坤作为我们饭后调侃，游戏玩笑，带着每个人对别人的讥讽，嘲笑越传越广…</p>\n<p>至此，大部分网民在心中都被烙下：差劲=蔡徐坤 这样一种刻板印象。</p>\n<p>但可笑的是</p>\n<p>大部分玩这个梗的人，连最熟悉的那句“全面制作人你们好，我是练习时长两年半的个人练习生，蔡徐坤。”中的“个人练习生”的含义是什么，“时长两年半”的概念是什么都不知道。</p>\n<p>可能你会说：哎笔者你刚还不是说我们没有义务与责任了解他吗？那我们不知道含义也没什么吧。</p>\n<p>是的，</p>\n<h3><a id=\"_64\"></a>我们没有义务去了解一个被全网追着抹黑的他，</h3>\n<h3><a id=\"_66\"></a>我们没有责任去关心一个整天活在谩骂，人格侮辱的他，</h3>\n<p>我们甚至连基本的尊重都没有给一个仅21周岁的他，</p>\n<p>就是这样，很多人把自己的无知当成理所当然，毫无节制的，毫无下限的诋毁！谩骂！</p>\n<p>笔者反问一句：他有义务与责任来承受这些侮辱与谩骂吗？</p>\n<p>注意这里是谩骂与侮辱，而非批评，而非具备逻辑与事实的批评！</p>\n<p>笔者知道你们懒，帮你们找了个人练习生背后的含义：</p>\n<p>个人练习生是指没有签约经纪公司的练习生，自己浏览资料进行练习，自行报名参加各种选秀节目，获得一定的曝光率之后可能会收到经纪公司的洽谈，决百定是否与公司签约。<br />\n这是什么意思，意思是他没有靠山，身后空无一人…</p>\n<p>众所周知，一个明星的背后，都是有资本操控的，大家平常说的炒作就是其运作而生的。</p>\n<p>不会公关，不会运营，没有强大成熟的作业团队，单枪匹马地杀入最复杂的娱乐圈，企图能分到一杯羹。</p>\n<p>这背后是一个二十岁青年的热血与野心，他的胆量绝非屏幕后每个键盘侠可比拟的！</p>\n<p>在这里笔者不打算寻找图片，文章举例他的善举，因为有好的就会有坏的。笔者在这拿出他做好事的图文，某些人便会拿出他犯错的图文。</p>\n<blockquote>\n<p>人无完人，谁能保证自己绝不犯错，圣贤都不敢说。</p>\n</blockquote>\n<p>别跟我说谁谁谁就没有像蔡徐坤一样做错事，背后资本运作，银幕呈现前的剪辑，某些明星不过是靠这些掩人耳目。但蔡徐坤当时没有啊，连工作室都只有三四个并不是很强的人，不熟悉公关的前提下，他只能任人摆布。</p>\n<p>就像那句：坏人之所以是坏人，是因为，他被抓住了…</p>\n<p>他可不见得比那些明星差。</p>\n<p>“娘的要命，亏还是个男的。”“他这样打篮球，就是在侮辱篮球。”“歌欣赏不来，唱的什么玩意。”等等这些，笔者只要打开网络平台搜索关于他的东西，这些言论铺天盖地，随处可见。</p>\n<p>笔者不想也不能对这些言论加以评价与干涉，每个人都有权发出声音，表达自己的思想与看法，如同笔者现在这篇小文一样。</p>\n<p>网友的评论是必须存在的，无论褒贬。</p>\n<p>他不可能取悦每一个人，他不可能做到完美，不可能面面俱到，他会犯错，他会迷茫。</p>\n<p>这是蔡徐坤必须面对的，没有任何商量的余地。</p>\n<p>如果一个明星一点错误都不犯，网上的声音全都是无节制的赞扬，那这个明星背后的资本是有多强啊…</p>\n<h3><a id=\"_109\"></a>所以网民可以批评，可以指责和追究，</h3>\n<h3><a id=\"_110\"></a></h3>\n<p>但在低龄化趋势的网络大环境下，某些评论真的不堪入目。</p>\n<p>笔者为此专门搜索相关微博与贴吧，里面的言论与图片，简直可怖之极。有遗像，有棺材，各种祷求他丧失性命的言论等等，这些甚至波及家人…</p>\n<p>笔者知道还有更丧尽天良的言论，笔者知道还有毫无下限的图片，笔者知道你们想看，也知道放上图片你们也许会为此感到愤怒，进而使文章更有说服力。</p>\n<p>但笔者真的对这些言论与图片连直视的勇气都没有，笔者不可能放一些自己不想看的东西进文章里面。</p>\n<p>可是，笔者可以选择不放图片进自己的文章，蔡徐坤能选择不让网友恶搞自己的图片吗？</p>\n<p>他选择不了，因为他背后力量不够。于是，他选择了法律手段。试图捍卫自己最后那点尊严，却被网友误导成了告B站，以此引发网上一片波澜。</p>\n<p>网络真的是一把锋利的双刃剑。对，双刃剑，小心点，键盘侠们。</p>\n<p>这篇小文笔者不匿名，会不会被攻击？不知道。</p>\n<p>但作为年龄相差无几的笔者，真的很佩服蔡徐坤。</p>\n<p>他有勇气，面对网上言论攻击依然坚持登台做自己喜欢做的事；</p>\n<p>他有野心，他目标非常明确，他的锋芒开辟着前进的道路；</p>\n<p>他有青稚中的成熟，他对舞台的驾驭能力与把握能力是一流的，他展现着与年龄不符的成熟与魅力；</p>\n<p>说真的，笔者很看好他，越努力越幸运这句话将会在他身上又一次验证。相信他会把网上言论当成自身垫脚石，一步步成就他的野心，实现他的梦想。</p>\n<p>（<em>以上皆为个人观点，码字不易，不喜…喷吧</em>）</p>\n');
INSERT INTO `article_body` VALUES (1048308662394683392, '算法有多种分类方式，可以根据实现方式分类，也可以根据设计方法分类，还可以根据应用领域进行分类。不同的分类方式有不同的特点。\n\n按照实现方式分类，可以将算法分为递归算法、迭代算法、逻辑算法、串行算法和并行算法和分布式算法、确定性算法和非确定性算法、精确算法和近似算法等。\n\n**递归算法**(recursion algorithms)是一种不断调用自身直到指定条件满足为止的算法。这是一种重要的算法思想。有关递归算法的详细内容，参见本章后面的相关节次。\n\n**迭代算法**(iteration algorithms)是采用计算机解决问题的一种基本方法。该算法主要是利用计算机运算速度快、适合做重复性操作的特点，让计算机重复执行某种结构或一组指令或一些步骤，在每次执行这种结构(或指令或步骤)时，都从变量的原值推出它的一个新值。也就是说，迭代算法通过从一个初始值出发寻找一系列近似值来解决问题。迭代算法的基本步骤包括确定迭代变量、建立迭代关系式、对迭代过程和结束方式进行控制。\n\n**逻辑算法**(logical algorithms)又称为逻辑演绎、演绎逻辑，是一种以一般概念、原则为前提，推导出个别结论的思维方法，即根据某类事物都具有的一般属性、关系来推断该类事物中个别事物所具有的属性、关系的推理方法。例如，水果都含维生素，猕猴桃是水果，所以猕猴含维生素。\n\n如果算法指令在计算机中执行的过程是一个指令接着一个指令，在指定的时刻只能有一个指令在执行，那么该算法是就**串行算法(serial algorithms)**。与串行算法对应的是并行算法、分布式算法。**并行算法**(parallel algorithms)是并行计算中的重要问题，指在并行机上同时用很多个处理器联合求解问题的方法。**分布式算法(distributed algorithms)**是一种可以借助计算机网络进行运算的方法。分布式算法广泛应用于通信、科学计算、分布式信息处理等领域。在并行算法和分布式算法中，成本消耗不仅涉及到每一个处理器本身处理数据的消耗，而且包括处理器之间通信所耗费的成本。因此，在选择是采用串行算法，还是并行算法或分布式算法时，要综合考虑成本因素。\n\n**确定性算法**(deterministic algorithms)是最常见到的算法，其计算行为是可预测的。在确定性算法中，给定一个特定的输入，总是会产生相同的输出结果，且其计算过程总是一样的。例如，求解一元二次方程根的算法就是一个典型的确定性算法。与确定性算法相比，**不确定性算法(non-deterministic algorithm)**是指计算行为是不可预测的。在很多运算过程中，往往有许多因素造成运算过程或结果是不确定的。在不确定算法中，运算过程往往有一个或多个选择点，且各种选择都有可能发生。\n\n一般地认为，**精确算法**(exact algorithms)是指总是可以找到最优解的算法，**近似算法**(approximate algorithms)则是指寻找接近最优解的满意解的算法。在很多实际问题中，往往只能找到近似解，因此近似算法更加有效。\n\n如果根据设计方法来分类，可以将算法分为穷举法、分治法、线性规划法、动态规划法、贪心算法、回溯法等。\n\n**穷举法(exhaustive search)**，又称为**强力搜索法(brute-force search)**、**枚举法**(enumeration method)，是一种解决问题的基本方法，该方法枚举出所有可能的解决方案，然后对每一个可能的解决方案进行测评以便找到满足条件的方案。例如，寻找自然数n的所有除数、中国传统的百元买百鸡问题(公鸡每只5元、母鸡每只3元、小鸡3只1元，百元买百鸡，问共有多少种买法？)、国际象棋中的8皇后问题等，穷举法是解决这些问题的有效方法。在这种方法中，算法的主要成本是需要枚举出所有可能的解决方案，解决方案数量会随着问题中数据规模的增加而急剧地增大。因此，这种方法适合问题中数据规模有限的情况，或者问题限于特定领域中。\n\n**分治法**(divide and conquer algorithm)的基本思想是把一个大问题分解成多个子问题，这些子问题可以继续再分解(递归方式)，直到分解后的子问题容易解决为止，然后把这些子问题的解决方案组合起来得到最终的结果。其主要步骤如下：按照指定的约束条件把问题进行分解直至得到容易解决的子问题，分别解决每个子问题，把子问题的方案组合起来。需要注意的是，分治法与递归法不同，虽然两者都强调层层分解得到子问题，但是递归强调子问题的形式与初始问题的形式完全一样，而分治法则不强调子问题的形式与初始问题完全一样，只是强调子问题是否容易得到解决，不同的子问题可以有不同的解决方式。二分搜索算法就是一个典型的分治法，其基本思想是，对于有序序列，确定待查记录的范围，然后逐步缩小范围直到找到记录为止。\n\n**线性规划法**(linear programming method，LPM)又称为线性规划技术，是一种解决多变量最优决策的典型方法。线性规划法是指在各种相互关联的多变量约束条件下，解决一个对象的线性目标函数最优化的问题。其中，目标函数是决策者要求达到目标的数学表达式，用一个极大或极小值来表示；约束条件是指实现目标的能力资源和内部条件的限制因素，用一组等式或不等式表示。线性规划法是经营管理决策中最常用的数学方法，主要用来解决管理决策、生产安排、交通设计、军事指挥等问题。\n\n**动态规划法**(dynamic programming method，DPM)是1953年美国应用数学家Richard Bellman提出用来解决多阶段决策过程问题的一种最优化方法。多阶段决策过程是把研究问题分成若干个相互联系的阶段，每一个阶段都做出决策，从而使整个过程达到最优化。动态规划法是一种多阶段决策方法，其基本思想是按时空特点将复杂问题划分为相互联系的若干个阶段，在选定系统行进方向之后，从终点向始点逆向计算，逐次对每个阶段寻找决策，使整个决策过程达到最优。该方法又称为逆序决策过程。许多实际问题利用动态规划法处理往往比线性规划法更有效。动态规划法与分治法类似，都是将问题归纳为较小的、相似的子问题，通过求解子问题产生一个全局解。但是，分治法中的各个子问题是独立的，一旦求出各个子问题的解后，可以自下而上地将子问题的解合并成问题的最终解。动态规划法则允许这些子问题不独立，该方法对每个子问题只解一次，并将结果保存起来，避免每次碰到时都重复计算。动态规划法适合于解决资源分配、优化调度等优化问题。\n\n**贪心算法**(greedy algorithms)类似于动态规划法，在对问题求解时，先把问题分成若干个子问题，总是贪心地做出在当前看来是最好的选择。也就是说，贪心算法不是从整体最优上加以考虑，所做出的决策仅是在某种意义上的局部最优解。虽然对于许多问题，贪心算法不能给出整体最优结果，但是贪心算法是运算速度最快的方法，并且对许多问题能产生整体最优解或整体最优解的近似解。Kruskal提出的最小生成树算法就是一个典型的贪心算法。贪心算法与动态规划法类似，但也有不同之处。贪心算法的当前选择可能要依赖已经做出的所有选择，但不依赖于有待于做出的选择和子问题。动态规划法的当前选择不仅依赖已经做出的所有选择，而且还依赖于有待于做出的选择和子问题。\n\n**回溯法**(backtracking algorithms)是一种选优搜索法，按选优条件向前搜索，以达到目标。当搜索到某一步时，发现原先选择并不优或达不到目标，就退回上一步重新选择。这种走不通就退回再走以便达到优化目的的方法称为回溯法。如果搜索方式合理的话，回溯法往往比穷举法要快，因为回溯法可以根据一次尝试而删除大量可选的解决方案。\n\n如果根据应用领域进行分类的话，算法的种类就更多了。每种应用领域都会有大量的算法。一些典型的算法包括排序算法、搜索算法、图论算法、机器学习、加密算法、数据压缩算法、语法分析算法、数论与代数算法等。', '<p>算法有多种分类方式，可以根据实现方式分类，也可以根据设计方法分类，还可以根据应用领域进行分类。不同的分类方式有不同的特点。</p>\n<p>按照实现方式分类，可以将算法分为递归算法、迭代算法、逻辑算法、串行算法和并行算法和分布式算法、确定性算法和非确定性算法、精确算法和近似算法等。</p>\n<p><strong>递归算法</strong>(recursion algorithms)是一种不断调用自身直到指定条件满足为止的算法。这是一种重要的算法思想。有关递归算法的详细内容，参见本章后面的相关节次。</p>\n<p><strong>迭代算法</strong>(iteration algorithms)是采用计算机解决问题的一种基本方法。该算法主要是利用计算机运算速度快、适合做重复性操作的特点，让计算机重复执行某种结构或一组指令或一些步骤，在每次执行这种结构(或指令或步骤)时，都从变量的原值推出它的一个新值。也就是说，迭代算法通过从一个初始值出发寻找一系列近似值来解决问题。迭代算法的基本步骤包括确定迭代变量、建立迭代关系式、对迭代过程和结束方式进行控制。</p>\n<p><strong>逻辑算法</strong>(logical algorithms)又称为逻辑演绎、演绎逻辑，是一种以一般概念、原则为前提，推导出个别结论的思维方法，即根据某类事物都具有的一般属性、关系来推断该类事物中个别事物所具有的属性、关系的推理方法。例如，水果都含维生素，猕猴桃是水果，所以猕猴含维生素。</p>\n<p>如果算法指令在计算机中执行的过程是一个指令接着一个指令，在指定的时刻只能有一个指令在执行，那么该算法是就<strong>串行算法(serial algorithms)</strong>。与串行算法对应的是并行算法、分布式算法。<strong>并行算法</strong>(parallel algorithms)是并行计算中的重要问题，指在并行机上同时用很多个处理器联合求解问题的方法。**分布式算法(distributed algorithms)**是一种可以借助计算机网络进行运算的方法。分布式算法广泛应用于通信、科学计算、分布式信息处理等领域。在并行算法和分布式算法中，成本消耗不仅涉及到每一个处理器本身处理数据的消耗，而且包括处理器之间通信所耗费的成本。因此，在选择是采用串行算法，还是并行算法或分布式算法时，要综合考虑成本因素。</p>\n<p><strong>确定性算法</strong>(deterministic algorithms)是最常见到的算法，其计算行为是可预测的。在确定性算法中，给定一个特定的输入，总是会产生相同的输出结果，且其计算过程总是一样的。例如，求解一元二次方程根的算法就是一个典型的确定性算法。与确定性算法相比，**不确定性算法(non-deterministic algorithm)**是指计算行为是不可预测的。在很多运算过程中，往往有许多因素造成运算过程或结果是不确定的。在不确定算法中，运算过程往往有一个或多个选择点，且各种选择都有可能发生。</p>\n<p>一般地认为，<strong>精确算法</strong>(exact algorithms)是指总是可以找到最优解的算法，<strong>近似算法</strong>(approximate algorithms)则是指寻找接近最优解的满意解的算法。在很多实际问题中，往往只能找到近似解，因此近似算法更加有效。</p>\n<p>如果根据设计方法来分类，可以将算法分为穷举法、分治法、线性规划法、动态规划法、贪心算法、回溯法等。</p>\n<p><strong>穷举法(exhaustive search)</strong>，又称为<strong>强力搜索法(brute-force search)</strong>、<strong>枚举法</strong>(enumeration method)，是一种解决问题的基本方法，该方法枚举出所有可能的解决方案，然后对每一个可能的解决方案进行测评以便找到满足条件的方案。例如，寻找自然数n的所有除数、中国传统的百元买百鸡问题(公鸡每只5元、母鸡每只3元、小鸡3只1元，百元买百鸡，问共有多少种买法？)、国际象棋中的8皇后问题等，穷举法是解决这些问题的有效方法。在这种方法中，算法的主要成本是需要枚举出所有可能的解决方案，解决方案数量会随着问题中数据规模的增加而急剧地增大。因此，这种方法适合问题中数据规模有限的情况，或者问题限于特定领域中。</p>\n<p><strong>分治法</strong>(divide and conquer algorithm)的基本思想是把一个大问题分解成多个子问题，这些子问题可以继续再分解(递归方式)，直到分解后的子问题容易解决为止，然后把这些子问题的解决方案组合起来得到最终的结果。其主要步骤如下：按照指定的约束条件把问题进行分解直至得到容易解决的子问题，分别解决每个子问题，把子问题的方案组合起来。需要注意的是，分治法与递归法不同，虽然两者都强调层层分解得到子问题，但是递归强调子问题的形式与初始问题的形式完全一样，而分治法则不强调子问题的形式与初始问题完全一样，只是强调子问题是否容易得到解决，不同的子问题可以有不同的解决方式。二分搜索算法就是一个典型的分治法，其基本思想是，对于有序序列，确定待查记录的范围，然后逐步缩小范围直到找到记录为止。</p>\n<p><strong>线性规划法</strong>(linear programming method，LPM)又称为线性规划技术，是一种解决多变量最优决策的典型方法。线性规划法是指在各种相互关联的多变量约束条件下，解决一个对象的线性目标函数最优化的问题。其中，目标函数是决策者要求达到目标的数学表达式，用一个极大或极小值来表示；约束条件是指实现目标的能力资源和内部条件的限制因素，用一组等式或不等式表示。线性规划法是经营管理决策中最常用的数学方法，主要用来解决管理决策、生产安排、交通设计、军事指挥等问题。</p>\n<p><strong>动态规划法</strong>(dynamic programming method，DPM)是1953年美国应用数学家Richard Bellman提出用来解决多阶段决策过程问题的一种最优化方法。多阶段决策过程是把研究问题分成若干个相互联系的阶段，每一个阶段都做出决策，从而使整个过程达到最优化。动态规划法是一种多阶段决策方法，其基本思想是按时空特点将复杂问题划分为相互联系的若干个阶段，在选定系统行进方向之后，从终点向始点逆向计算，逐次对每个阶段寻找决策，使整个决策过程达到最优。该方法又称为逆序决策过程。许多实际问题利用动态规划法处理往往比线性规划法更有效。动态规划法与分治法类似，都是将问题归纳为较小的、相似的子问题，通过求解子问题产生一个全局解。但是，分治法中的各个子问题是独立的，一旦求出各个子问题的解后，可以自下而上地将子问题的解合并成问题的最终解。动态规划法则允许这些子问题不独立，该方法对每个子问题只解一次，并将结果保存起来，避免每次碰到时都重复计算。动态规划法适合于解决资源分配、优化调度等优化问题。</p>\n<p><strong>贪心算法</strong>(greedy algorithms)类似于动态规划法，在对问题求解时，先把问题分成若干个子问题，总是贪心地做出在当前看来是最好的选择。也就是说，贪心算法不是从整体最优上加以考虑，所做出的决策仅是在某种意义上的局部最优解。虽然对于许多问题，贪心算法不能给出整体最优结果，但是贪心算法是运算速度最快的方法，并且对许多问题能产生整体最优解或整体最优解的近似解。Kruskal提出的最小生成树算法就是一个典型的贪心算法。贪心算法与动态规划法类似，但也有不同之处。贪心算法的当前选择可能要依赖已经做出的所有选择，但不依赖于有待于做出的选择和子问题。动态规划法的当前选择不仅依赖已经做出的所有选择，而且还依赖于有待于做出的选择和子问题。</p>\n<p><strong>回溯法</strong>(backtracking algorithms)是一种选优搜索法，按选优条件向前搜索，以达到目标。当搜索到某一步时，发现原先选择并不优或达不到目标，就退回上一步重新选择。这种走不通就退回再走以便达到优化目的的方法称为回溯法。如果搜索方式合理的话，回溯法往往比穷举法要快，因为回溯法可以根据一次尝试而删除大量可选的解决方案。</p>\n<p>如果根据应用领域进行分类的话，算法的种类就更多了。每种应用领域都会有大量的算法。一些典型的算法包括排序算法、搜索算法、图论算法、机器学习、加密算法、数据压缩算法、语法分析算法、数论与代数算法等。</p>\n');

-- ----------------------------
-- Table structure for article_tag
-- ----------------------------
DROP TABLE IF EXISTS `article_tag`;
CREATE TABLE `article_tag`  (
  `article_id` bigint(0) NOT NULL,
  `tag_id` bigint(0) NOT NULL,
  PRIMARY KEY (`article_id`, `tag_id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE,
  INDEX `tag_id`(`tag_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_tag
-- ----------------------------
INSERT INTO `article_tag` VALUES (1048014784940736512, 2);
INSERT INTO `article_tag` VALUES (1048014784940736512, 14);
INSERT INTO `article_tag` VALUES (1048016245409972224, 2);
INSERT INTO `article_tag` VALUES (1048016245409972224, 14);
INSERT INTO `article_tag` VALUES (1048017972309786624, 9);
INSERT INTO `article_tag` VALUES (1048019308057198592, 14);
INSERT INTO `article_tag` VALUES (1048026009816793088, 14);
INSERT INTO `article_tag` VALUES (1048027135333105664, 1);
INSERT INTO `article_tag` VALUES (1048027135333105664, 2);
INSERT INTO `article_tag` VALUES (1048027135333105664, 3);
INSERT INTO `article_tag` VALUES (1048028956206301184, 15);
INSERT INTO `article_tag` VALUES (1048028956206301184, 19);
INSERT INTO `article_tag` VALUES (1048308662394683392, 14);

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `category_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES (1, '/blogapi/v1/dist/static/category/front.svg', '前端', 'Web页面的样式结构以及交互实现');
INSERT INTO `category` VALUES (2, '/blogapi/v1/dist/static/category/back.svg', '后端', '程序设计架构思想，管理数据库');
INSERT INTO `category` VALUES (3, '/blogapi/v1/dist/static/category/life.svg', '生活', '记录下有意思的经历和感悟');
INSERT INTO `category` VALUES (4, '/blogapi/v1/dist/static/category/database.svg', '数据库', '按照数据结构来组织、存储和管理数据的仓库');
INSERT INTO `category` VALUES (5, '/blogapi/v1/dist/static/category/coding.svg', '编程语言', '语言特点与高级语法');
INSERT INTO `category` VALUES (6, '/blogapi/v1/dist/static/category/algorithm.svg', '算法', '算法分类与技巧理解');
INSERT INTO `category` VALUES (7, '/blogapi/v1/dist/static/category/interview.svg', '面试', '面试分享');

-- ----------------------------
-- Table structure for comments
-- ----------------------------
DROP TABLE IF EXISTS `comments`;
CREATE TABLE `comments`  (
  `id` bigint(0) NOT NULL,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `create_date` bigint(0) NOT NULL,
  `article_id` bigint(0) NOT NULL,
  `author_id` bigint(0) NOT NULL,
  `parent_id` bigint(0) NOT NULL,
  `to_uid` bigint(0) NOT NULL,
  `level` int(0) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comments
-- ----------------------------
INSERT INTO `comments` VALUES (1048015108741005312, '第一次写博客，逻辑不是很清晰，望广大网友指正！', 1669907873103, 1048014784940736512, 1048012356757487616, 0, 0, 1);
INSERT INTO `comments` VALUES (1048015455505088512, '后续还有模板方法模式的分析，欢迎阅读，互相学习进步！', 1669907955778, 1048014784940736512, 1048012356757487616, 0, 0, 1);
INSERT INTO `comments` VALUES (1048016465631903744, 'Spring中的设计模式暂时只写了这两部分，如果后续大家关注多，会继续更新其他的设计模式。谢谢！', 1669908196611, 1048016245409972224, 1048012356757487616, 0, 0, 1);
INSERT INTO `comments` VALUES (1048016583445708800, '目前只有单例模式、适配器模式和模板方法模式。', 1669908224700, 1048016245409972224, 1048012356757487616, 1048016465631903744, 1048012356757487616, 2);
INSERT INTO `comments` VALUES (1048016715138465792, '另外还有六种设计模式的运用会慢慢加进来。', 1669908256098, 1048016245409972224, 1048012356757487616, 1048016465631903744, 1048012356757487616, 2);
INSERT INTO `comments` VALUES (1048018248928329728, 'docker的一篇简要介绍，非常简略，基本上看完能对Docker有一个大概了解，想要继续深入需要更多学习。', 1669908621782, 1048017972309786624, 1048012356757487616, 0, 0, 1);
INSERT INTO `comments` VALUES (1048018866040471552, '言简意赅，逻辑清晰，作为入门还不错，感谢博主！', 1669908768913, 1048017972309786624, 1048018809429950464, 0, 0, 1);
INSERT INTO `comments` VALUES (1048019444963475456, '讲解比较肤浅，后续会从源码角度解析注解的底层机制!', 1669908906939, 1048019308057198592, 1048018809429950464, 0, 0, 1);
INSERT INTO `comments` VALUES (1048020063514263552, '连夜看完，启发很大！感谢博主，希望加快更新其他设计模式！', 1669909054413, 1048014784940736512, 1048018809429950464, 1048015108741005312, 1048012356757487616, 2);
INSERT INTO `comments` VALUES (1048020747827544064, '本IKUN觉得非常不错，学校的java课没有讲注解，博主的文章一看就懂！Respect！！！', 1669909217566, 1048019308057198592, 1048020495523381248, 1048019444963475456, 1048018809429950464, 2);
INSERT INTO `comments` VALUES (1048021329887887360, '大家快看，这里有个小黑子！', 1669909356340, 1048019308057198592, 1048021253429919744, 1048019444963475456, 1048018809429950464, 2);
INSERT INTO `comments` VALUES (1048021831346290688, '小鸡子，露出坤脚了吧~', 1669909475897, 1048019308057198592, 1048021541100453888, 1048019444963475456, 1048018809429950464, 2);
INSERT INTO `comments` VALUES (1048023404067684352, '请大家不要再评论区谈论与文章无关内容！', 1669909850863, 1048019308057198592, 1048012356757487616, 0, 0, 1);
INSERT INTO `comments` VALUES (1048024148074299392, '请大家不要讨论与本文无关内容，共同维护良好社区环境，谢谢！', 1669910028248, 1048019308057198592, 1048018809429950464, 1048019444963475456, 1048018809429950464, 2);
INSERT INTO `comments` VALUES (1048025044879409152, '写的很好，催更催更哈哈哈', 1669910242063, 1048019308057198592, 1048024823428546560, 0, 0, 1);
INSERT INTO `comments` VALUES (1048026075772223488, '谢谢大家阅读！', 1669910487847, 1048026009816793088, 1048024823428546560, 0, 0, 1);
INSERT INTO `comments` VALUES (1048027312391454720, '有需要文中Deomo代码的同学可以找我', 1669910782680, 1048027135333105664, 1048012356757487616, 0, 0, 1);
INSERT INTO `comments` VALUES (1048027380645363712, '写错了，Demo', 1669910798953, 1048027135333105664, 1048012356757487616, 1048027312391454720, 1048012356757487616, 2);
INSERT INTO `comments` VALUES (1048029221177262080, '什么情况，我认识网站的管理员，你看法就看，怎么标签选择python？你号没了', 1669911237770, 1048028956206301184, 1048012356757487616, 0, 0, 1);
INSERT INTO `comments` VALUES (1048029488056631296, '不好意思，贵网站没有其他标签可选，又非要我选一个，我随便选的。', 1669911301399, 1048028956206301184, 1048021253429919744, 1048029221177262080, 1048012356757487616, 2);
INSERT INTO `comments` VALUES (1048029718474915840, 'y1s1，玩这梗的确实挺无聊的', 1669911356335, 1048028956206301184, 1048020495523381248, 0, 0, 1);
INSERT INTO `comments` VALUES (1048030022385795072, '兄弟，你看看博主的昵称，我笑死了哈哈哈哈', 1669911428793, 1048028956206301184, 1048021541100453888, 1048029718474915840, 1048020495523381248, 2);
INSERT INTO `comments` VALUES (1048030328481906688, '博主，我想要代码跑一跑，怎么联系您？', 1669911501772, 1048027135333105664, 1048024823428546560, 0, 0, 1);
INSERT INTO `comments` VALUES (1048030566659653632, '加我的QQ吧，我发给你，或者可以访问我的github账号，就在社区主页左边。', 1669911558558, 1048027135333105664, 1048012356757487616, 1048030328481906688, 1048024823428546560, 2);
INSERT INTO `comments` VALUES (1048363573794832384, '已经联系管理员添加了，已经修正过来，抱歉', 1669990953646, 1048028956206301184, 1048021253429919744, 1048029221177262080, 1048012356757487616, 2);

-- ----------------------------
-- Table structure for permission
-- ----------------------------
DROP TABLE IF EXISTS `permission`;
CREATE TABLE `permission`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of permission
-- ----------------------------

-- ----------------------------
-- Table structure for sys_log
-- ----------------------------
DROP TABLE IF EXISTS `sys_log`;
CREATE TABLE `sys_log`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `create_date` bigint(0) NULL DEFAULT NULL,
  `ip` varchar(15) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `method` varchar(100) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `module` varchar(10) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `nickname` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `operation` varchar(25) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `params` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `time` bigint(0) NULL DEFAULT NULL,
  `userid` bigint(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_log
-- ----------------------------

-- ----------------------------
-- Table structure for sys_user
-- ----------------------------
DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user`  (
  `id` bigint(0) NOT NULL,
  `account` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '账号',
  `admin` bit(1) NULL DEFAULT NULL COMMENT '是否管理员',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `create_date` bigint(0) NULL DEFAULT NULL COMMENT '注册时间',
  `deleted` bit(1) NULL DEFAULT NULL COMMENT '是否删除',
  `email` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `last_login` bigint(0) NULL DEFAULT NULL COMMENT '最后登录时间',
  `mobile_phone_number` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '手机号',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '密码',
  `salt` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '加密盐',
  `status` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '状态',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1404448588146192387 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_user
-- ----------------------------
INSERT INTO `sys_user` VALUES (1048012356757487616, 'AKBoom', b'0', '/blogapi/v1/dist/static/user/lanmao.svg', 1669907216979, b'1', '', 1669907216979, '', '夜空中最靓的猩', '723f008d3fb7529cda0b36ee1ad5bc69', '1a420994ec870bbb85d1d2feb3329975', '');
INSERT INTO `sys_user` VALUES (1048018809429950464, 'Max', b'0', '/blogapi/v1/dist/static/user/lihuamao.svg', 1669908755416, b'1', '', 1669908755416, '', '化悲痛为力量', '71491b72148c14584743f026d2cf486e', '87db6d90feb0e42649552bc96336d102', '');
INSERT INTO `sys_user` VALUES (1048020495523381248, 'IKUN', b'0', '/blogapi/v1/dist/static/user/jiafeimao.svg', 1669909157412, b'1', '', 1669909157412, '', 'IKUN', '4fc6c2834bb8a3c1fa807df0eedac423', '1dbd435192cdc9f82935c1be3485cace', '');
INSERT INTO `sys_user` VALUES (1048021253429919744, 'KUNKUN', b'0', '/blogapi/v1/dist/static/user/jumao.svg', 1669909338111, b'1', '', 1669909338111, '', '坤你太美', '44dbdecd2383d26ef3ed7bea7ce212c9', 'bad9f2420057438705f528f836381d2d', '');
INSERT INTO `sys_user` VALUES (1048021541100453888, '真IKUN', b'0', '/blogapi/v1/dist/static/user/lanbaimao.svg', 1669909406697, b'1', '', 1669909406697, '', '守护最好的坤坤', 'cd19f8f0808165177569bbad9cc2c87b', '55a0f4920e28cb2a740bce7e97f664ef', '');
INSERT INTO `sys_user` VALUES (1048024823428546560, 'BEIBEI', b'0', '/blogapi/v1/dist/static/user/mao.svg', 1669910189265, b'1', '', 1669910189265, '', '一路向北', '81f12c7eaed9c7fdfe7f3f9481c82d43', 'd16de3149d3ba87dcb23c43f1a72e992', '');

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '标签图标',
  `tag_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '标签名称',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 17 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (1, '/blogapi/v1/dist/static/tag/springboot.svg', 'springboot');
INSERT INTO `tag` VALUES (2, '/blogapi/v1/dist/static/tag/spring.svg', 'spring');
INSERT INTO `tag` VALUES (3, '/blogapi/v1/dist/static/tag/springcloud.svg', 'springcloud');
INSERT INTO `tag` VALUES (4, '/blogapi/v1/dist/static/tag/springsecurity.svg', 'springsecurity');
INSERT INTO `tag` VALUES (5, '/blogapi/v1/dist/static/tag/mybatis.png', 'mybatis');
INSERT INTO `tag` VALUES (6, '/blogapi/v1/dist/static/tag/mybatisplus.svg', 'mybatisplus');
INSERT INTO `tag` VALUES (7, '/blogapi/v1/dist/static/tag/redis.jpg', 'redis');
INSERT INTO `tag` VALUES (8, '/blogapi/v1/dist/static/tag/mysql.jpg', 'mysql');
INSERT INTO `tag` VALUES (9, '/blogapi/v1/dist/static/tag/docker.jpg', 'docker');
INSERT INTO `tag` VALUES (10, '/blogapi/v1/dist/static/tag/linux.jpg', 'linux');
INSERT INTO `tag` VALUES (11, '/blogapi/v1/dist/static/tag/vue.png', 'vue');
INSERT INTO `tag` VALUES (12, '/blogapi/v1/dist/static/tag/css.png', 'css');
INSERT INTO `tag` VALUES (13, '/blogapi/v1/dist/static/tag/javascript.png', 'javascript');
INSERT INTO `tag` VALUES (14, '/blogapi/v1/dist/static/tag/java.png', 'java进阶');
INSERT INTO `tag` VALUES (15, '/blogapi/v1/dist/static/tag/python.png', 'python');
INSERT INTO `tag` VALUES (16, '/blogapi/v1/dist/static/tag/elasticsearch.svg', 'ElasticSearch');
INSERT INTO `tag` VALUES (17, '/blogapi/v1/dist/static/tag/algorithm.png', '算法');
INSERT INTO `tag` VALUES (19, '/blogapi/v1/dist/static/tag/idea.png', '想法');

SET FOREIGN_KEY_CHECKS = 1;
